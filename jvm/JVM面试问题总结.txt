⚫方法重写，和方法重载的区别和原理
方法重载就是同一个方法名。参数个数，顺序，类型不一致的不同方法，又叫编译时多态，是因为在编译过程中，就可以确定调用的具体是哪个方法，那么就可以把对应方法的符号引用替换成直接引用。
方法的重写是在继承关系的前提下，子类重写父类的方法，


⚫多态的原理（方法重写）
多态就是子类重写父类的方法，父类声明，子类创建。那么在编译时是无法确定调用的是子类方法，还是父类方法，所以只有在运行期间才可以确定，
在运行期间通过指令中的符号引用，会先找到父类方法区中的方法表。找到该方法的偏移量，因为子类重写父类的方法，所以子类的方法表中的该方法与父类中方法表中的方法的偏移量是一致的，所以根据父类的偏移量，
去子类的方法表中寻找重写的方法。这时就可以找到是哪个对象的方法了，这个过程也叫动态绑定


⚫哪些方法不可以被重写？
final，static，private，构造方法，因为这些方法在编译期间就可以确定内存中的具体方法，并且在运行期间不可变，这其实就是静态绑定机制。所以这些方法是于类绑定在一起的，无法重写


⚫jvm调优工具：
jps查看进程id
jstat 查看java程序运行时，堆信息得相关情况，jstat -gc pid 显示gc信息，每个eden，幸存区，老年代，元空间占用情况，使用情况
jmap用来查看堆内存使用状况 命令：jmap -heap pid 显示GC算法，堆配置信息，以及各区域的使用情况
jstack可以查看线程得使用情况。例如死锁，死循环。请求外部资源导致长时间等待得问题，还有线程阻塞和等待得情况
VisualVM能够运行在jdk1.6以上版本上，性能分析工具，，可用于：cpu性能分析，内存性能分析，线程性能分析


⚫生产中如何定位内存溢出，并解决？
JVM中有一个命令参数。可以在发生OOM时，记录内存快照信息并生成一个dump文件，我们只需要分析堆内存快照就行了， visualvm分析dump文件,主动dump文件会造成STW，所以设置参数，让系统出现oom时自动dump
java进程启动时加上开启此功能的启动参数，如下:
java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/app.hprof -jar app.jar


⚫jvm常用的参数：
–Xms（堆的初始容量）
-Xmx（堆的最大容量）
-XX:InitialHeapSize=268435456  初始堆
-XX:MaxHeapSize=4294967296    最大堆
-XX:MetaspaceSize 设置元空间大小
-XX:MaxMetaspaceSize  默认大约4096MB，怕影响其他程序
-XX:MinMetaspaceFreeRatio=40  默认百分之40   当GC之后空间小于40  那么自动增长
-XX:MaxMetasaceFreeRatio=70   默认百分之70   当GC之后空间大于70  那么自动释放

-Xss 设置栈空间大小，jdk1.5以后默认每个线程1M  （-Xss256k count线程数 1874）
-Xmn：设置新生代大小
-XX：NewRatio:新生代与老年代占比
-XX：SurviviorRatio：设置eden和幸存区的占比
-XX：PrintFlagsInitial：查看所有参数默认值
-XX: PrintGCDetails：输出GC详细日志
-XX: MaxTenuringThreshold 这是新生代垃圾的最大年龄


⚫方法区是否涉及垃圾回收？什么时候进行回收？
在jdk1.7中把静态变量，和字符串常量池移到了堆中。在jdk1.8方法从永久代变成了元空间。也就是说方法区大小不受jvm内存限制，而受本地内存大小的限制，
那么从1.8开始，方法区的垃圾回收，是根据你设置参数-XX:MetaspaceSize来决定什么进行垃圾回收，回收废弃的常量和无用的类（该class没有被任何地方引用，也没有反射调用）
如果该值设置的太小，会频繁GC。


⚫jvm中为什么需要栈：
首先栈中存储的是栈帧，每个栈帧对应一个方法，执行方法时会把当前方法的栈帧压入栈，也叫当前帧，
那么一个栈帧中，存储的数据有：操作数栈（方法执行的指令）、局部变量表、动态链接、返回参数。
因为程序执行期间需要快速运行，就需要栈来完成这个工作，栈的执行速度比较快  仅次于寄存器，


⚫java堆内存分配过程：
0.首先判断是否在栈上分配内存（如果开启逃逸分析，并且满足逃逸分析的要求，就会在栈上分配）
1.然后新创建的对象大多数会分配在eden区，先说一下分配在eden的流程，如果分配不下，那么进行minorGC，把新生代剩余存活的对象复制到其中一个幸存区，
此时这批对象GC年龄+1，如果minorGC后仍然无法分配，那么分配到老年区，老年区如果分配不下，那就就进行fullGC，如果fullGC分配不下，就OOM。
2.有一批大对象例如数组会直接进入老年代（前提是serial和ParNew收集器），为了防止大对象复制导致降低GC的性能
3.还有就是如果minorGC之后，对象的年龄达到默认的15次，会直接进入老年区，
4.还有minorGC之后，幸存区一批对象的大小大于幸存区的50%，那么会把这批对象中年龄最大的对象。或者大于最大年龄的对象的对象，放入老年区，这样做是为了那些长期存活的对象尽早进入老年代
5.还有一个分配机制就是：空间担保机制。为了防止频繁的fullGC


⚫什么是空间担保机制：
老年代连续可用的空间>新生代GC之后对象总和 或者 老年代可用的连续空间>历次minorGC升入老年代对象的平均大 ,
空间担保机制就是，就是一种担保，担保人是老年代。因为老年代不知道能不能存下新生代晋升的对象，所以先进行判断，如果判断不满足先进行minorGC。然后在看能不能存下。
，如果没有这个判断，直接晋升老年代，并且存不下那么就fullGC了，如果每次都这样会降低GC效率，有了担保机制，先进行minorGC多了一层保护机制。


⚫java类加载过程：
类加载：采用双亲委派加载机制，先委托父类加载，父类加载不了，在使用子类加载器加载（BootStrap ClassLoader、Extension ClassLoader、Application ClassLoader），不同的类加载器可以加载包名类名相容的类
连接：
	验证：格式检验：检验二进制字节流是否规范、语义检查：java语法规范、字节码验证：字节码是否规范不会危害计算机，符号引用验证，
	准备：为静态变量分配空间，赋默认值，其中final修饰的变量，直接赋值。final修饰的变量在类加载是就为该变量添加了一个ConstantValue属性，该属性中存的就是设置的值，在此阶段把ConstantValue中的值赋值给变量
	解析：将符号引用替换直接引用
初始化：调用<init>方法，初始化过程就是执行类构造器方法的过程（对static修饰的类变量的手动赋值还有主动调用代码块）
			(类的构造方法名使用字符串<init>表示，静态初始化块实际上是一个方法，其方法名使用<clinit>表示)

⚫触发类加载的四个指令：
1）new：使用new关键字实例化对象
2）getSatic：读取一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外）
3）putSatic：设置一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外）
4）invokeStatic：调用一个类的静态方法


⚫创建对象的过程：
首先检查该类释放已经加载过，如果没有加载，那么开始调用类的加载器加载该类，加载过程中会发生，将calss文件加载到内存中，为该类分配内存空间，分配方式分为指针碰撞、或者空闲列表，分配内存的方式取决于：Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
然后为成员变量初始化0值，然后设置设置对象头信息，包括：对象哈希码，GC年龄，锁的标志等等
然后执行<init>方法，也就是构造方法，也就是类的初始化
初始化顺序为：
父类静态静态变量/父类静态代码块
子类静态静态变量/子类静态代码块
父类成员变量/父类普通代码块/父类构造方法
子类成员变量/子类普通代码块/子类构造方法


⚫创建对象的几种方式：
new、反射获取对象、对象序列化、Object的clone方法


⚫双亲委派加载机制的作用？
防止重复加载同一个calss，委托父加载器加载，加载过了，就不会在加载了，保证数据安全，防止核心class被篡改，
不同的加载器加载同一个calss也不是同一个calss对象，


⚫破坏双亲委派加载机制有哪些？
a)	第一次破坏：实现calssloader 重写loadClass （之后推荐实现findCalss方法，是loadClass中一个子方法）
b)	第二次破坏：SPI机制，解决基础类加载用户代码类，推出线程上下文类加载器
c)	第三次破坏：OSGI就是利用自定义类加载机制来完成模块化热部署，而他实现类加载机制就没有完全遵循自上而下的委托机制，有很多平级的类加载器查找类，一种网状结构的类加载方式


⚫栈溢出的情况有哪些？
栈是线程私有的，每个线程有自己的栈，jdk1.5以后每个线程的栈空间为1M，每个方法执行对应一个栈帧入栈，如果是一个递归方法，递归次数比较多，那么就很多栈帧入栈，导致该线程的栈空间耗尽。StackOverflowError
虚拟机栈可以动态扩展的，如果扩展时无法申请到内存，就报栈溢出OutOfMemoryError，


⚫垃圾回收是否涉及栈？栈内存空间越大越好么？
线程私有，线程结束，栈空间自动清理。 栈空间越大，那么容纳的线程数就越少


⚫JVM栈会出现线程安全问题么？
因为执行一个方法的时候伴随着很多条指定，这一组指定执行期间，cpu会切换线程，那么当前线程被挂起。其他线程修改了这个对象的值，被挂起的线程恢复时使用的就是被修改过的值。


⚫本地方法栈存在的原因？
是对jvm的有效扩充，本地方法栈是用来执行本地方法，本地方法是非java语音，可以融合c++，c语言的程序，本地方法也可以于底层操作系统交互


⚫什么是解释器，编译器，两者有什么区别
编辑器和解释器都是java用来把字节码转换成机器码的执行器。至于两者的区别呢，解释器；在java字节码执行时，大多数情况下都用解释器会逐行解释翻译成机器码。
但是针对一些热点代码，我们会用编译器来编译，编译以后的机器码存在方法区。作为一个缓存。当我下次执行时，直接调用缓存中的机器码来执行，省去了很多时间，提高了性能。
至于热点代码：编译器提供了两种方式：
①基于采样的热点探测：虚拟机会周期性的检测每个线程的栈顶。如果发现某些方法经常出现在栈顶。那么这个方法就是热点方法
②基于计数器的热点探测（hotspot使用）：为每个方法准备两个计数器，方法调用计数器和回边计数器。两个计数器都有自己的阈值（client：1500、server：10000），超过阈值就会触发jit编译器。
回边计数器就是循环体循环的次数，但是编译都是以方法为单位编译的


⚫为什么同时使用解释器，编译器
服务刚运行时，是有解释器来逐行解释的，但是随着程序的使用逐行解释显得效率低下。所以针对热点代码会使用编译器来编译然后缓存编译后的结果，下次就不用再解释了。提高效率


⚫jit编译器优化有哪些
公共子表达式消除、方法内联、方法逃逸分析：只有方法没有发生逃逸，jit才会进行优化。
	对象栈上内存分配：通俗讲就是把个别的数据或者对象分配在栈上，这样就无需在堆上分配内存，也无须进行垃圾回收了
	变量替换：把一个聚合量变成多个标量。聚合量就是一个对象，标量就是一个成员变量。好处就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了
	同步锁消除：如果同步代码块被证实只有一个线程所访问，那么就会把锁去掉。变成非同步的，（就是使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除）


⚫逃逸分析并不成熟为什么：
因为逃逸分析自身分析有一定的复杂性，也是一个耗时的过程，经过逃逸分析以后，发现没有一个对象是不逃逸的，那这个逃逸分析的过程就白白浪费掉了，所以开启逃逸分析也未必是一种优化。


⚫垃圾回收机制中。是怎么判断对象是否存活的？GCroot集合包含哪些内容？
通过两种算法标记是否是否是存活。
引用计数算法：对每个对象维护一个整数计数器，如果被引用了那么就加一，如果引用失效就减一，当一个对象引用数为0时，说明对象可以被回收了，
但是引用计数法有一个问题，就是无法解决循环引用的问题，循环引用的对象无法被GC会导致oom。所以java用可达性分析算法
可达性分析算法：就是以根对象集合为起点，通过引用链，连接能够到达的对象，如果对象没有被间接或者直接的连接，那么这个对象就是不可达对象，就会被垃圾回收器回收（对象头会存储该对象是否被标记）
其中GCroot包含，
	栈帧中的本地变量表所引用的对象，
	本地方法栈的栈帧中所引用的对象
	类静态变量所引用的对象。
	方法区常量池中常量所引用的对象。
	所有被同步锁synchronized持有的对象
	跨代引用对象。老年代引用新生代的对象
因为这些对象是大多数不会被GC，所以更适合作为GCroot，同时为了保证可达性分析算法的准确性，在标记阶段会出现STW现象，也就是程序会暂时的停顿下来。
无论什么垃圾回收器。所以现在的垃圾回收器的性能提升点都在于，怎么让程序停顿的时间更短，来达到快速的GC的目的



⚫垃圾回收算法有哪些，分别有什么优缺点，jvm使用哪些垃圾收集器
复制算法：从根节点开始搜索，所有存活的对象，并把这些存活复制到另一个空间，并回收该空间的剩余垃圾对象，最后将to和from的空间互换，完成GC，
这种算法适合用在存活率比较低的空间，这样在复制的对象的时候，可以更快速复制，所以适合用在幸存区。但是如果存活对象太多会降低该算法效率，并且该算法会使用双倍的内存空间。优点：空间连续，无内存碎片
标记清除算法：分为两个阶段：
	标记：从根节点开始遍历所有被引用的对象，并在对象头中记录为可达的对象。
	清除：会遍历内存中所有的对象，并找出没有被标记的对象，将其回收
		缺点：因为内存中对象可能分布在任意角落，所以被清理后的内存是一个碎片化的内存，并不连续。并且针对这个不连续的内存还会维护一个空闲列表，来记录被清空内存的地址。如果是一个大数组需要连续的内存空间。那么就很难分配空间
		优点：不需要双倍空间
标记压缩算法：
标记清除压缩算法：先标记，然后整理：把存活的对象压缩到一端。然后清理边界外的所有空间，那么此时空间就是一个规整有序的空间，jvm需要维护指针，记录空闲空间的起始地址，这样下次分配内存时就可以使用指针碰撞的方式来分配
	优点：空间连续。无内存碎片。无需双倍空间
	缺点：效率低于复制算法和标记清理算法，因为有一个压缩的过程，如果对象被引用，移动以后需要改变引用的地址


⚫System.gc()与Runtime.gc()的区别
system.java
public void gc(){
	Runtime.getRuntime.gc();
}// System.gc()中调用的就是Runtime.gc() 
开发中尽量不要用gc，gc会导致程序卡顿stw


⚫java软引用和弱引用的区别，用法，怎么解决oom的问题
软引用：软引用是用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示，在内存不足的时候JVM才会回收该对象，使用场景：图片缓存
弱引用：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示（被弱引用所引用的对象只能生存到下一次GC之前），弱引用的出现是为了垃圾回收的
，在静态内部类中，经常会使用软引用，以软引用的方式来保存外部类的引用，当外部类需要被JVM回收时，那内部类的引用也可以被回收，防止内存泄露
虚引用：跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。仅用来处理资源的清理问题   Phantom Reference


⚫ThreadLocal可能造成内存泄漏的原因？
ThreadLocal类中有一个静态内部类ThreadLocalMap，实际上我们ThreadLocal的get，set方法都是ThreadLocalMap中的方法，ThreadLocalMap底层就是一个entry数组，key存储的就是一个WeakReference修饰的ThreadLocal的引用。
value存储的就是set进来的值。那么当我们GC时。就会把弱引用修饰的key回收掉。但是对应的value还是存在，value不能被回收。（因为这个时候ThreadLocalMap会存在key为null但是value不为null的entry项）
因为entry对象引用了value，而entry又被ThreadLocalMap引用，而ThreadLocalMap又被ThreadLocal引用，所以没有了key的value依然无法被回收。
ThreadLocalMap是ThreadLocal静态内部类，Entry是ThreadLocalMap的静态内部类，也就是这个关系：this.table = new ThreadLocal.ThreadLocalMap.Entry[16];


⚫什么是内存泄漏，内存溢出？
内存泄漏就是一些没有被用到的对象，无法被回收，占用内存空间，却无法释放。久而久之就会导致内存溢出。一些连接池，网络连接socket，io对象没有被close，就会导致内存泄漏
内存溢出就是OOM，无法分配内存给新的对象，导致oom


⚫垃圾收集器种类有哪些？都有哪些优缺点
串行：Serial、Serial old(老年代)：
	Serial采用复制算法。是java最古老的垃圾回收器。在javaclient模式下是默认的垃圾回收器，在垃圾回收时，会暂停用户线程，单线程执行垃圾回收，在单核的情况下，这种垃圾回收器，要优于并行收集器，因为可以省去并发线程来回切换的开销。
	并且Serial old采用标记整理算法。可以作为CMS的娄底收集方案。使用场景：适合客户端的小内存应用，交互不是很频繁。
并行：ParNew、Parallel Scavenge、Parallel Old(老年代)
	ParNew是采用复制算法的新生代垃圾回收器，在java server模式下是默认的垃圾回收器，并且配合CMS作为老年代回收器，ParNew在垃圾回收时，需要暂停用户线程，多线程并行垃圾回收。在多核的cpu中，ParNew更高效一些
	Parallel Scavenge相比较于ParNew,更关注于吞吐量，PS可以开启自适应策略，自动调节内存参数达到一个高吞吐的目的，并且配合Parallel Old作为老年代回收器一起使用。
	Parallel Old采用标记整理算法的并行，老年代回收器，是java8的默认垃圾回收器。在多核的情况下。这种并行回收器的效率还是很高的
并发收集器：CMS(老年代),G1(整堆)
	CMS是一款具有跨时代意义的并发垃圾回收器，可以与用户线程并发垃圾收集，从而减少应用线程的停顿时间，达到低延迟。更适用于交互频繁的应用。可以给用户带来更好的体验，
	它采用的标记清除算法，通过指定参数-XX:CMSFullGCsBeforeCompaction，执行多少次FullGC之后进行压缩处理，防止产生内存碎片，垃圾回收共分为四个阶段
		① 初始标记：这个阶段会暂停用户线程。只标记于GCroot直接关联的对象。由于对象不多，所以速度非常快，用户停顿时间比较短
		② 并发标记：这个阶段与用户线程并发执行，标记于GCroot关联的所有对象，通过写入屏障来防止对象被漏标（写入屏障是解决一开始死亡的对象，后来存活了。为了标记这种存活的对象）
		③ 重新标记: 由于上个阶段与用户线程并发执行，对象的引用会发生变化，于是要从当前GCroot和指针更新的区域触发，开始重新标记增量的对象，已经标记过的对象会跳过，这个阶段会暂停用户线程，并且多线程来标记垃圾对象，
		④ 并发清除：与用户线程并发执行来清理垃圾对象，
	优点：低延迟，并发执行
	缺点：因为标记清除算法，所以会产生许多内存碎片。由于没有连续的内存空间，大对象无法分配,会导致FULLGC，由于并发执行会导致用户线程变慢，并且并发标记，会产生一些浮动垃圾，无法清理，只能下次GC才能回收
	浮动垃圾：是在初始标记阶段是可达对象（存活），而在并发标记阶段变成了不可达对象（非存活），那么在重新标记阶段是无法检测到该对象的，因为曾经标记过存活的对象，不会再次进行从GCroot遍历对该对象再次标记，而且要解决浮动垃圾必须从第一阶段开始，很耗时，所以这种浮动垃圾是可以容忍的，下次GC回收就可以了。
但是反过来，如果初始标记阶段是非存活对象，而并发标记阶段变成了存活对象，那么这种存活对象是不可以被清除，清除会导致程序报错，这种不能容忍，所以重新标记阶段是对这种对象重新标记。而不是浮动垃圾的标记
        三色标记法：
               白色：还没有被搜索过的对象（会被当成垃圾对象）、灰色：正在搜索的对象、黑色：搜索完成的对象


⚫有了新生代的ParNew、为什么还要ParallelScavenge，两者的区别？
ParNew是利用复制算法的新生代垃圾回收器。而ParallelScavenge与ParNew算法一致，但是ParallelScavenge更关注于吞吐量，PS有一个自适应调节策略，自动调节你内存可用空间的大小，来达到一个高吞吐量。
只需要关注三个参数即可，①最大停顿时间②吞吐量的大小（GC的占用时间）③开启自适应策略，PS试用于交互比较少，后台计算比较多的场景，例如科学计算，工资支付等场景。


⚫聊一下G1垃圾回收器的特点，和优缺点？
G1垃圾回收器诞生于jdk1.7，并在jdk1.9完全替换掉CMS，CMS在jdk14被删除，G1采用采用了全新的分区算法，他把堆分成2048个分区，每个区域的大小控制在2-32M之间，一搬占用2的N次幂大小，
每个region代表不同的年代eden、Survivor、old、Humongous的区，Humongous的区是用来存储存活是时间短的大对象，
G1的优势主要在于以下几点：
一、并行与并发：在垃圾收回期，暂停用户线程。多线程并行执行，有效利用多核的能力。在清理垃圾期间部分工作可以与用户线程并行执行。
二、分代收集：G1收集器会把整个堆划分为年轻代和老年代，其中年轻代又划分为eden，Survivor空间。但是年轻代空间不是固定不变的，当年轻代占满时，jvm会分配新的空闲分区加入到年轻代
三、空间整合：分区之间采用复制算法。从堆的角度来看是标记整理算法，这两种算法都可以避免内存碎片
四、可预测的停顿时间模型:G1通过设置最大回收时间参数。G1会维护一个优先列表，根据Region里面垃圾堆积的价值大小。在回收时间内，回收价值最大的region，保证了G1收集器在规定时间内获得更大的回收效率，
适用：服务器应用端，大内存，多处理器的机器
优点：G1未必能做到cms最好的低延迟，但是在最坏的情况下，G1效率远高于cms，
缺点：G1为了垃圾收集，产生的内存占用，以及程序运行时的额外执行负载都比CMS要高。
	在小内存时CMS的性能大概率优于G1 ，
优化建议：
	避免使用-XX:NewRatio、-Xmn参数设置新生代大小。整个年轻代的空间是根据参数计算出来的（计算参数中包含暂停时间的参数），并且会动态变化。所以说如果指定年轻代的大小，将使暂定时间参数设置失去意义
G1算法中通过：写屏障+SATB来防止对象被漏标


⚫G1回收过程：
1.年轻代GC
	并行的、独占式的（STW发生）的垃圾回收，可能会发生对象的代晋升，将会把对象放入Survivor或者是老年代，
		扫描根节点（包括老年代指向新生代的对象也属于根节点。通过rset记录的），维护更新rset，进行复制移动等处理
2.老年代并发标记
	当堆空间的内存占用达到阈值（-XX:InitiatingHeapOccupancyPercent，默认45%）就开始老年代的并发标记过程
		初始标记：直接可达的对象，会STW
		跟区域扫描：扫描引用新生代的老年代对象，这种对象不能被清理
		并发标记：计算每个region的可回收对象的大小和活动。发现某些region中所有对象都是垃圾，那这个region就会被立即回收，
		再次标记：短暂STW修正上一次的标记结果，有一些漏标的对象再次标记 （写屏障+SATB）
		独占清理：计算各个region的存活对象和GC回收比例，并进行排序（回收价值高低排序），识别可以混合回收的区域，准备回收价值最高的区域
		并发清理阶段：识别并清理完成空闲的区域
3.混合回收
	包括年轻代和老年代的垃圾回收


⚫cardTable和Rset是用来干嘛的？
在CMS算法中:
	cardTable是一种btye类型的数组结构，它的作用是用来标记老年代对象是否引用了新生代对象，逻辑上是把老年代分成是若干个卡片（card），每个card大小为128个字节，同时每一个card对应一个标志位，
这个标志位连起来就是我们说的cardTable，如果这个card引用了新生代对象，那么对应的标志位上状态就是1，这项操作就是通过write barrier写屏障来实现，所以byte[i]=1，代表的就是i+1的卡片上有引用新生代，
一个card占1024位，对应一个cardtable占1位，所以一个标志位只占对应内存的1/1024大小，所以直接扫描cardtable就可以找到引用新生代的对象，大大提高了GC的性能
在G1算法中:
	GI把每个region分成若干个card，每个card大小位512个字节，每个card对应一个标志位，就是cardTable，如果这个card引用了外部的对象，那么这个card会被标记成dirty_card，，被引用的region会维护一个rset，
 是一种hashTable结构，key存储的是外部region的起始地址，value存储的是被标记的cardtable中数组下标。所以GC时不用扫描所有的堆，只扫描cardTable就可以了找到外部引用的对象了。这个对象就作为GCroot对象


⚫Java虚拟机在“用户线程”都结束后会后退出。
守护线程在没有用户线程可服务时自动离开
Java垃圾回收线程就是一个典型的守护线程
