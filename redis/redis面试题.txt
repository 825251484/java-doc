redis端口号6379
keys test* 模糊查询key


⚫怎么使id不重复且连续
	redis的incr命令 增减
	snowflake雪花算法



⚫雪花算法规则
	SnowFlake算法生成id的结果是一个64bit大小的整数
	0 - 00000000 00000000 00000000 00000000 00000000 0 - 00000000 00 - 00000000 0000
	   [				41bit		  ] [	10bit   ] [	   12bit    ]

解析：
	1) 1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0
	2) 41位，用来记录时间戳（毫秒）。
	3) 41位可以表示2^41−1个数字，如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 2^41−1，减1是因为可表示的数值范围是从0开始算的，而不是1。
		也就是说41位可以表示2^41−1个毫秒的值，转化成单位年则是(2^41−1)/(1000∗60∗60∗24∗365)=69年
	4) 10位，用来记录工作机器id。可以部署在2^10=1024个节点，包括5位datacenterId和5位workerId
	5) 5位（bit）可以表示的最大正整数是2^5−1=31，即可以用0、1、2、3、....31这32个数字，来表示不同的datecenterId或workerId
	6) 12位，序列号，用来记录同毫秒内产生的不同id。
		12位（bit）可以表示的最大正整数是2^12−1=4095，即可以用0、1、2、3、....4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号
		由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。

	
⚫redis五种数据结构特点，和使用场景
1.string  适合json格式查询，锁 setnx，数字增减功能（限整数）：incr 递增、decr递减，也可指定数值增减incyby，计数器、共享用户session（用户登录token）、分布式锁
2.hash  适合对属性字段增删改，记录登录信息，商品信息等
3.list  可存 重复  有序的，双向链表，左右增删元素 LPUSH  LPOP，也可以指定位置增删   消息模式（队列模式、发布订阅）  一个列表可以存储2^32-1个元素。支持两端插入和弹出，并可以获得指定位置（或范围）的元素，可以充当数组、队列、栈等。Irange可以基于list分页，高性能分页
4.set  不重复，且无序  sadd、srem、sdiff：差集、sinter：交集、sunion：并集   抽奖：由于集合无需不重复，用spop命令随机弹出一个元素，共同好友
5.zset 为每个元素设置一个分数（score）作为排序依据， 不重复，排行榜、热搜（热度值是分数）


⚫redis高级数据类型
1.bitMap：二进制形式的数组保存数据，主要是计数使用。占用内存比较少。每个元素只能存储0、1两个值。
	命令：
		SETBIT key offset value  key字符串，offset必须是数字，表示数组下标（可以表示活跃用户id），value只能是0或1（访问过是1），
		setbit：如果key不存在创建一个bitmap，并且在对应的位置设置对应的值。
		getbit：取对应位置的值。
		bitcount：统计数组中一共有多少个1
	使用场景：用于计数使用，最大的容量2^32，offset取值范围可以是0~2^32-1。可以用于判断用户的在线状态。最大占用的存储空间是512m，可以进行位运算：AND、OR、XOR、NOT
		1.可以作为统计用户数量：命令bitcount ket  ，统计连续三天访问的用户数量 bitop and，三天内没有访问的用户数量 bitop not，统计在线用户，用时间做key，用户id做偏移量
		2.可以做布隆过滤器
2、HyperLogLog
	计数统计的数据类型，可以使用很小的空间就可以统计非常庞大的数据量。
	2^64个基数只需要12kb的内存空间即可。
	有一定的误差
	pfadd key value：创建一个key，并且添加基数。value存在将不会重复插入
	pfcount：统计基数
	pfmerge：合并两个基数。
	使用场景：记录网站ip注册数，每日访问ip数，页面实时uv，在线用户等，（海量数据统计，可以容忍误差的情况）
3、Geospatial：底层使用zset
	地理位置存储数据类型。
	geoadd key 经度 维度 城市名称：创建并添加一个位置
	geodist：计算两个位置之间的距离
	geopos：根据名称查询位置
	georadius：根据给出的经纬度查询范围之内的位置
	georadiusbymember：根据已经存在的成员找出范围之内的位置


⚫redis消息模式
队列模式：使用list类型的lpush和rpop实现消息队列
	rpop没有消息会去出null
	brpop命令，它如果从队列中取不出来数据，会一直阻塞，在一定范围内没有取出则返回null

发布订阅模式
	subscribe：订阅一个channel
	publish：向channel中发送消息。
	如果订阅者掉线后，发送的消息就无法接收到。不可靠的
Redis Stream：
	概念：redis 5.0版本新增加的数据结构，是一种基于内存的MQ，stream是一种append only（AOF）的数据结构，虽然是一种数据结构，但是它实现了更强大的功能消息功能，类似于kafka消息队列，可以保证消息不会丢失，同时还有一个组的概念，组内可以有多个消费者
	类似于kafka的内存队列，可以保证消息不丢失。
	消息队列相关命令：
		xadd：创建队列并且向队列中添加消息。
		xlen：查看队列的长度
		xrange：查看队列中的元素。
		xrevrange：反向查看
		xread：读取队列中的消息，消费消息。 消费过的消息，不会消失，会一直存在，可以再次消费
		xread count 1 streama key id ：count消息数量，不指定的话消费所有id中的消息，指定的话只消费N条，id获取大于当前id的消息
		xread block 0 streams 阻塞读取
		xdel：删除消息
	消费者组：是在消息的基础之上建立的组，组内消息消费过，就不存在了，就不能在消费了，但是该消费队列中的消息一直都存在
		xgroup：创建一个消费者组
		xgroupread：以消费者组模式进行消息消费
		等等
		xreadgroup group group1 c1 count 1 streams s1：group1自定义组名称，c1自定义消费者，s1：消息队列key


⚫redis事务
	redis事务只是一个批处理，有隔离性（把所有命令放入队列中一起执行），但是没有原子性，非原子操作，不支持回滚，保持原子性可以使用lua
	Multi：开启事务
	Exec：执行
	Discard：不执行
	watch利用该操作可以实现乐观锁的操作
	缺点：key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能
	Redis为什么没有回滚操作？
		1. 大多数错误都是 操作或指令错误
		2. 为了性能 day03


⚫redis lua表达式
	1.概念lua：是一个脚本语言，redis中集成了lua的解释器，可以在redis中直接运行lua脚本。
	2.在redis中执行lua脚本命令：
		EVAL script numkeys key [key ...] arg [arg ...] ，script字符串lua字符串，numkeys参数个数，key从redis传入lua的参数的key，arg从redis传入lua的参数value 
	3.在lua脚本中执行redis命令：
		redis.call()：返回值就是redis命令执行的返回值，如果出错，返回错误信息，不继续执行
		redis.pcall()：返回值就是redis命令执行的返回值，如果出错了 记录错误信息，继续执行
		举例：eval “return redis.call("get","a")” 0   意思是返回redis中的get(a) ,0表示无参数
	4.在redis中执行lua文件：
		可以使用redis-cli --eval命令指定一个lua脚本文件去执行，也可以往脚本中传入参数
		注意：./redis-cli --eval redis.lua b , 2。参数中b空格,空格2其中空格是不能少的。
	5.特点：
		1. 减少网络开销，在Lua脚本中可以把多个命令放在同一个脚本中运行
		2. 原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说，编写脚本的过程中无需担心会出现竞态条件
		3. 复用性，客户端发送的脚本会永远存储在redis中，这意味着其他客户端可以复用这一脚本来完成同样的逻辑
		lua 教程 https://www.runoob.com/lua/lua-tutorial.html


⚫reids锁
	优点：Redis是基于内存存储，并发性能好。
	缺点：
	   1. 需要考虑原子性、超时、误删等情形。
	   2. 获锁失败时，客户端只能自旋等待，在高并发情况下，性能消耗比较大。
	分类：
	   1.setnx
	   2.set(key, value, NX, PX, milliseconds)
	   3.RedissonRedLock lock = redisson.getLock("className"); lock.tryLock(获取锁时间,锁过期时间,时间单位ms) 
	问题：
	   1.线程安全问题（原子性）：先获取锁。在设置过期时间不是原子操作
		解决方案：
			1、使用set(key, value, NX, PX, milliseconds) 
			2、RedissonRedLock lock = redisson.getLock("className"); lock.tryLock(获取锁时间,锁过期时间,时间单位ms) 
	   2.死锁问题：因故障导致解锁代码未执行，未设置过期时间
		解决方案：设置过期时间
	   3.锁误删除：A线程执行，执行比较慢，超时后，自动释放锁，但是A还没执行完代码，这个时候B进来获取锁，执行代码，在B执行期间，A执行结束，然后执行代码释放锁，把B的锁给释放了。
		解决方案：
			1.设置key对应的value。根据value判断释放时当前线程。
			2.用lua表达式：String scrip = "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else retrun 0 end"
			3.开启子线程对锁续命
			4.使用Redisson
	   4.锁丢失：数据还没同步到从节点，这个时候从节点挂了，那么就会造成锁丢失
		解决方案：1.使用Redisson中的红锁（RedLock）,红锁采用主节点过半机制
	锁推荐：
		方案1：
			如果要使用普通的redis锁（并非Redisson），重点：
			一定要使用 SET(key, value, NX, PX, milliseconds)
			value具有唯一性
			释放锁要使用lua脚本，保证原子性	
		方案2：使用Redisson
		方案3：使用zk
	分布式锁对比zk、redis、数据库锁（乐观悲观锁）：
		从性能角度（从高到低）：缓存redis > zk > 数据库锁
		从可靠性角度（从高到底）：zk > 缓存redis > 数据库锁
		因为zk是cp模型，强一致性模型，所以性能没有redis高，redis是ap模型
			
			
⚫Redisson中lock和setnx的区别？
jedis：
	场景：jedis是封装了redis的所有功能，更适合做缓存数据
	jedis带来的问题：
		jedis这种解锁有线程安全问题，因为get操作和del不是原子的，所以要使用lua表达式去解锁，而且这里要开子线程去锁的续命，因为jedis这种加锁解锁操作比较繁琐，而且要自己考虑锁的场景。所以Redisson就是解决了这些问题
		 if(uuid.equals(redisTool.get('Test')){
				redisTool.del('Test');
			}
Redisson:
	Redisson更适用于锁，而且也考虑了可重入锁的问题，还可以锁的续命(启动一个watch dog后台线程，不断的延长锁key的生存时间)，，省去了jedis.setnx的问题，jedis
	Redisson源码中加锁/释放锁操作都是用lua脚本完成的，封装的非常完善，开箱即用。
	Redisson中的红锁（RedLock）就是为了解决主节点加锁了，数据还没同步到从节点，这个时候从节点挂了，那么就会造成锁丢失，红锁采用主节点过半机制，即获取锁或者释放锁成功的标志为：在过半的master节点上操作成功。
	锁互斥机制
	自动延时机制
	可重入锁机制
参考链接：setnx和Redisson的区别：https://zhuanlan.zhihu.com/p/111354065


⚫RedisTemplate和StringRedisTemplate的区别
	1.StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。
		当你的redis数据库里面本来存的是字符串数据或者你要存取的数据就是字符串类型数据的时候，那么你就使用StringRedisTemplate即可，
	2.如果你的数据是复杂的对象类型，而取出的时候又不想做任何的数据转换，直接从Redis里面取出一个对象，那么使用RedisTemplate是更好的选择。
		RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。


⚫redis内存参数？
used_memory：数据存储的内存
used_memory_rss：redis进程内存
mem_fragmentation_ratio ： used_memory_rss / used_memory的比值。
	mem_fragmentation_ratio一般大于1，且该值越大，内存碎片比例越大。
	mem_fragmentation_ratio<1，说明Redis使用了虚拟内存，由于虚拟内存的媒介是磁盘，比内存速度要慢很多，当这种情况出现时，应该及时排查，如果内存不足应该及时处理，如增加Redis节点、增加Redis服务器的内存、优化应用等。一般来说，
	mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）；刚开始的mem_fragmentation_ratio值很大，是因为还没有向Redis中存入数据，Redis进程本身运行的内存使得used_memory_rss 比used_memory大得多。


⚫redis内存结构：
是一个类似于map的存储结构，封装了一个dict对象。该对象中有一个ht数组，是用来做rehash（扩容用的），只有ht[0],ht[1],其中ht[1]只有在rehash使用到，正常数据存储在ht[0]中，ht数组中封装了一个dictht对象。
dictht中存储table和size等信息，table是一个类似于hashtable的结构，是数组+链表的方式：dictEntry[4]数组+每个节点下挂一个单向链表，链表中每个节点存储的就是一个dictEntry对象，这个对象是一个Map结构，存储就是我们要的数据。
	dictEntry对象：
		next：指向下一个元素的指针
		key的指针：指向一个sds结构存储的字符串：C语言中字符串是以\0结尾的，不能满足redis的需求和性能
		value指针：指向一个redisObject结构的对象
			redisObject对象：
				type：五种对象类型
				encoding：编码
					对于Redis支持的每种类型，都有至少两种内部编码
						string类型：int、embstr、raw三种编码
						hash：ziplist(压缩列表)、hashtable哈希表（dictEntry对象）。编码转换：哈希中元素数量小于512个、或者哈希中所有键值对的键和值字符串长度都小于64字节。使用压缩列表
						list：ziplist(压缩列表)、linkedlist(双向链表)，因为存储数据大小涉及两者转换，转换也是费时复杂的操作，所以3.0之后使用：quickList快速列表
						set：intset整数集合、hashtable哈希表
						zset：ziplist(压缩列表)、skiplist跳跃表 
				ptr：指向value对象得指针（如果类型是string，那么sds结构中存储的value值）
				lru：记录最后一次被命令程序访问的时间
				refcount：当创建新对象时，refcount初始化为1；当有新程序使用该对象时，refcount加1；当对象不再被一个新程序使用时，refcount减1；当refcount变为0时，对象占用的内存会被释放。
				
				
⚫redis内存结构中编码的特点？
查看编码命令：object encoding key
int：8个字节的长整型。字符串值是整型时，这个值使用long整型表示。
embstr：可存储<=44字节的字符串，因为一个redisobject什么也不存时占16个字节，sds占4个字节，加一起正好时64个字节。
raw：超过44个字节的字符串
ziplist(压缩列表)：压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），
每个节点可以保存字符串或者整数值，放到一个连续内存区。由于内存是连续的，就减少了很多内存碎片和指针的内存占用，进而节约了内存。
   压缩链表内部结构：
     zlbytes：压缩列表占用内存总大小
     zltail：压缩列表，表尾节点的偏移量：用来倒序遍历压缩列表。
     zllen：节点数
     entry[]：元素具体信息
     zlend：压缩列表的末端标识符
   entry[]内部结构：
     previous_entry_length为一个整型值，记录了前一个节点整体占用字节的长度，
     encoding属性长度不定，其主要保存了当前节点的编码格式和节点的长度、
     content属性保存了该节点的实际的字符串或整型数据
   缺点：因为内次增删都会带来重新分配内存，所以元素特别多的时候。重新分配整个压缩列表的内存很耗时。
hashtable哈希表：dictEntry对象就 是hashtable结构，
linkedlist(双向链表)：双端链表同时保存了表头指针和表尾指针，并且每个节点都有指向前和指向后的指针；每个节点可以存储不同类型的值
quickList快速列表：因为存储数据大小涉及两者转换，转换也是费时复杂的操作，所以3.0之后使用：quickList快速列表，结构是：linkedlist和ziplist的结合。quicklist中的每个节点都是一个ziplist，每个节点都能够存储多个数据元素。
intset整数集合：1.集合中所有元素都是数字类型，2.元素中有一个是字符串 || 元素数量大于512时，都会转换成hashtable，
skiplist跳跃表：跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。除了跳跃表，实现有序数据结构的另一种典型实现是平衡树；大多数情况下，跳跃表的效率可
以和平衡树媲美，且跳跃表实现比平衡树简单很多，因此redis中选用跳跃表代替平衡树。跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。
	一开始用抛硬币的方式决定高度，后来用概率算法，


⚫redis内存划分的原因：
技能保证充分利用内存空间，又能保证我们的性能使用
对于c中的字符串来说，如果修改字符串，就要重新分配内存。因为如果不重新分配内存，字符串增大会造成内存溢出，如果字符串减少，会造成内存泄漏，所以sds采用预分配方式（分配的内存比实际需要的多）
使得修改字符串时减少了重新分配内存的概率


⚫redis 中数据的内存编码
查看编码命令：object encoding key
	1）String类型
		key-value：String-String，SDS结构体进行存储。
			int：8个字节的长整型。字符串值是整型时，这个值使用long整型表示。
			embstr：可存储<=44字节的字符串，因为一个redisobject什么也不存时占16个字节，sds占4个字节，加一起正好时64个字节。 redisobject（16byte）+ sds（4byte）+数据（44byte）=64byte
			raw：超过44个字节的字符串
	2）hash数据类型
		ziplist编码：每个压缩列表可以存储多个节点。并且该结构中存储了列表占用的字节数和偏移量，用来计算每个节点的位置
			1：hash中的元素数据量小于512个
			2：所有hash中的键值对字符串的长度都小于64个字节
		hashtable：dictEntry对象就是hashtable结构，只能从ziplist转hashtable不能反转
			1：hash中的元素数据量超过512个
			2：所有hash中的键值对字符串的长度都大于64个字节
	3）list数据类型
		ziplist(压缩列表,redis3.0之前)：每个压缩列表可以存储多个节点。并且该结构中存储了列表占用的字节数和偏移量，用来计算每个节点的位置
		linkedlist(双向链表,redis3.0之前)：双端链表同时保存了表头指针和表尾指针，并且每个节点都有指向前和指向后的指针；每个节点可以存储不同类型的值
		原因：因为存储数据大小涉及两者转换，转换也是费时复杂的操作，所以3.0之后使用：quickList快速列表
		QuickList(快速列表3.0之后)：linkedlist和ziplist的结合。quicklist中的每个节点都是一个ziplist，每个节点都能够存储多个数据元素。
	4）set数据类型
		intset：整数集合
			集合中所有的元素都是数值类型。
		hashtable：
			元素中有一个字符串形式的元素时转换成hashtable。
			集合中的元素数量大于于512时。
	5）zset数据类型
		ziplist：
			元素数据小于128
			所有的成员的长度小于64字节。
		skiplist：
			元素数据大于128
			或者有的成员的长度大于64字节。			


⚫了解内存编码是为了什么？
要估算redis中的数据占据的内存大小，需要对redis的内存模型有比较全面的了解，包括：hashtable、sds、redisobject、各种对象类型的编码方式等。
为了计算数据大小，分配最适合的空间，减少内存碎片，提高利用率（mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）,说明内存利用的比较好）


⚫redis内存分配器：
libc、tcmalloc、jemalloc（默认内存分配器）、
jemalloc内存分配器作为redis默认内存分配器，在减少内存分配方面做的相对比较好，jemalloc在64位系统中，将内存空间划分为：小、大、巨大三个范围，每个范围内又划分了许多小的内存单位，当redis存储数据时，会选择大小最合适的内存块进行存储。


⚫redis如何淘汰过期的key
主动：每100毫秒（1秒10次）随机抽取一些key（参数设置抽取多少），进行检测，删除掉已经过期的key，如果有超过25%的key过期，那么会继续抽取。如果小于25%，那么就在停止抽取，在下一秒继续抽取
被动：当客户端访问这个key的时候，会先判断这个key是否过期，过期则无返回


⚫redis优化
1.设置过期时间，避免数据过多堆积，占用内存
2.惰性删除：，redis4.0新增功能，异步延时删除，使用子线程来删除数据（删除操作时阻塞的），减少对主线程的阻塞（删除big key很耗时）。设置参数：1.超过最大内存时  2.数据过期时  3.执行del命令时  默认都是no
3.设置redis使用内存大小：maxmemory 1G ①32操作系统不设置：如果添加数据超过最大内存，redis会报错，②64操作系统，如果不设置的话，会使用虚拟内存（磁盘），磁盘查询，会影响查询效率
	设置了该参数后，会使用缓存淘汰策略（缓存置换策略）
		1.FIFO先进先出：已废弃
		2.LRU：淘汰最近最少使用的数据 
			1. noeviction：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；
			2. allkeys-lru：淘汰整个键值中最久未使用的键值；
			3. volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值；
			4. allkeys-random：随机淘汰任意键值;
			5. volatile-random：随机淘汰设置了过期时间的任意键值；
			6. volatile-ttl：优先淘汰更早过期的键值。
			注意：需要注意的是，当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有计算出可淘汰的key，结果和noeviction一样直接报错。
			底层原理：类似一个链表，最近访问的数据会被移动到表尾，最近添加的数据也会插入到表尾，而没有被访问的数据就会在偏向表头的位置，如果发送淘汰时，那么表头的数据就是最近最少使用的数据，就会被淘汰
		3.LFU：(较少使用)删除最近使用频次最低的数据，会导致最近插入的数据被删除。有可能最近插入的数据使用频次比较低，白说话，淘汰使用最少的数据
			Redis 4.0 版本中又新增了 2 种淘汰策略：
			1. volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值；
			2. allkeys-lfu：淘汰整个键值中最少使用的键值。
		4.如何自己实现淘汰策略:
			继承LinkHashMap重写removeEldestEntry方法，即可完成一个简单的LRU
			该构造函数可以实现一个按顺序访问，最近最少使用的内部链表，
			链表中最近最少使用在前面（表头），最多访问的在后面（表尾）
			每次get都会把get到的值放到链表的最后面，每次put值都会判断是否大于size，如果大于就删掉表头的值，也就是最老的值，如果小于size，那就直接把值放到表尾
			public class LRUmap extends LinkedHashMap {
				 LRUmap2(int max, Object lock) {
					//是否使用访问顺序遍历，是通过LinkedHashMap 的accessOrder参数控制的，true为访问顺序遍历，false为插入顺序遍历。
					第三个参数是true，意味着按访问顺序遍历，构造最近最少访问的内部链表.
					super((int) (max * 1.4f), 0.75f, true); //重点1：无需扩容， max*1.4刚好是0.71未达到扩容系数
					this.max = max;
					this.lock = lock;
				}
				// 重点2：重写LinkedHashMap的removeEldestEntry方法即可，在put的时候判断，如果为true，就会删除最老的
				@Override
				protected boolean removeEldestEntry(Map.Entry eldest) {
					return size() > max;
				}
			}
			注意：切记不要使用map.keySet()循环中使用get(key)，因为用这种方式, 第一次get()会修改keyset的顺序, 所以在第二次进行迭代时, 结构顺序发生了变化, 所以会报ConcurrentModificationException  
		5.如何实现LFU算法，可以为每个key设置一个计数器，每次访问计数器+1，当淘汰时淘汰计数最少的key
			文章：https://blog.csdn.net/ceoaxv5008/article/details/100956248
			
			
4.缩短键值对存储长度，数据越大，耗时越长（阻塞）
5.查看showlog慢查询日志
	slowlog-log-slower-than ：用于设置慢查询的评定时间，也就是说超过此配置项的命令，将会被当成慢操作记录在慢查询日志中，它执行单位是微秒 (1 秒等于 1000000 微秒)；
	slowlog-max-len ：用来配置慢查询日志的最大记录数
6.避免大量数据同时失效
	Redis 过期键值删除使用的是贪心策略，它每秒会进行 10 次过期扫描，此配置可在 redis.conf 进行配置，默认值是 hz 10 ，Redis 会随机抽取 20 个值，删除这 20 个键中过期的键，如果过期 key 的比例超过 25% ，重复执行此流程
7.根据分配内存的规则合理使用空间。例如存储17个字节的那就要分配32个字节来存储，那么剩下15个字节就是内存碎片，所以要合理估算数据大小，减少内存碎片，尽量使用整型、长整型来存储数据。redis会使用int编码代码字符串编码，更节省空间
8.共享对象：只包括0-9999的整数
9.使用 Pipeline 批量操作数据
10.要尽量使用 Redis 连接池，而不是频繁创建销毁 Redis 连接，这样就可以减少网络传输次数和减少了非必要调用指令。
	import redis.clients.jedis.JedisPool;
	import redis.clients.jedis.JedisPoolConfig;
11.使用分布式架构来增加读写速度
	主从同步
	哨兵模式
	Redis Cluster 集群
	Redis Cluster 应该是首选的实现方案，它可以把读写压力自动的分担给更多的服务器，并且拥有自动容灾的能力。
12.使用物理机而非虚拟机
13.禁用 THP 特性
		当开启了 THP 时，fork 的速度会变慢，fork 之后每个内存页从原来 4KB 变为 2MB，会大幅增加重写
	期间父进程内存消耗。同时每次写命令引起的复制内存页单位放大了 512 倍，会拖慢写操作的执行时
	间，导致大量写操作慢查询。例如简单的 incr 命令也会出现在慢查询中，因此 Redis 建议将此特性进
	行禁用


⚫缓存常见的问题
缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。
	解决：设置不同的过期时间Math.random()*10000
缓存击穿：缓存在某个时间点过期的时候，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
	解决：1.放入nginx本地缓存中，多级缓存ngnix/openresty-lua + jvm堆内存 + redis，2.热点key持久化，无失效，3.互斥锁 将：1.查询缓存 2.查询数据库 3.更新缓存 放入一个分布式锁中
缓存穿透：一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。
	解决：1.过滤非法值，空值或者负数，等，2.布隆过滤器 		
		  2：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。
		  3：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。（布隆表达式）  Bitmap中维护经常查询条件的数据（可设置多个布隆过滤器），getbit(key)返回0，就不查数据库，
缓存预热：
	1. 直接写个缓存刷新页面，上线前手工操作一下
	2. 数据量不大的时候，可以在项目启动的时候自动加载
	3. 定时刷新缓存
缓存更新：
	1. 定期去清理过期的缓存
	2. 当有用户请求过来时，先判断这个请求用到的缓存是否过期，过期的话就去底层系统得到新数据进行缓存更新
缓存降级：当访问量出现剧增、服务出现问题（相应时间慢或者不响应） 或非核心业务影响到核心流程的性能，还需要保证服务的可用性，即便有损服务
	解决：
		1.系统根据一些关键数据进行降级，配置开关实现人工降级
		2.对不同层度的错误，提供不同的降级方式：
			一般：ex有些服务偶尔网络抖动或者服务正在上线超时，可以自定降级
			警告：有些服务在一端时间内有波动（95%-100%），可以自定降级或人工降级，还有发送告警
			错误：可利用率低于90%，redis连接池被打爆了，数据库连接池被打爆，或者访问量突然猛增到系统能承受的最大阈值，这时候根据情况自动降级或人工降级
			严重错误：比如因为特殊原因数据错误了，需要紧急人工降级。redis服务出问题了， 不去查数据库，而是直接返回一个默认值（自定义一些随机值）
		3.双11期间禁用退款功能
			
缓存双写一致性：
	三种缓存策略：
		1.旁路缓存模式：写请求：先更新db，在删除缓存，读请求：先从缓存中读取，没有的话去查询数据库，然后更新缓存
		2.读写穿透：缓存服务付责db的更新操作，并且是同步写，redis并没有此功能
		3.异步缓存写入：缓存服务付责db的读写操作，但是是异步操作读写，很少用
	
	在双写的场景下，要先更新数据库，然后删除缓存，会带来哪些问题？
		1.为什么用删除缓存不用更新缓存呢？ 
			因为更新缓存会存在脏数据，
		2.为什么不先删除缓存，在更新数据库呢？ 
			因为如果是一读一写的时候，①A服务删除缓存，②B服务读取缓存，无数据读取，读取DB，设置缓存，③A服务更新数据库（更新玩数据库后不会再更新缓存了，因为已经采用删除缓存的方式了）。④那么缓存中的数据就不是最新数据了，如果A服务第一步删除缓存失败，那么也会造成数据不一致
		3.如果非要先删除缓存，在更新数据库，也是有办法的，会更麻烦一些，
			缓存延时双删：我们可以在B服务设置完缓存以后，A服务再删一遍缓存，这样下次读取数据时，就会从DB获取最新的数据了。
				延时双删流程：
					（1）先淘汰缓存
					（2）再写数据库（这两步和原来一样）
					（3）休眠1秒，再次淘汰缓存（这个时间根据B服务处理流程时间来决定）
					 这么做，可以将1秒内所造成的缓存脏数据，再次删除。
		4.先更新后删除，就没有问题了么？
			先更新数据库，然后删除缓存，就不会有问题么？也会有，但是这种场景发生的概率较小，
				- 请求A进行写操作，删除缓存，此时A的请求还没有执行完，事务还没提交，
				- 请求B查询发现缓存不存在
				- 请求B去数据库，如果A服务事务未提交，那么B查询到的就是旧值
				- 请求B将旧值写入缓存
				- 请求A将新值写入数据库
			所以如果一定要保持数据一致性的话，那就只能采用最终一致性，这种场景不会有强一致性的存在。也就是CAP只能保证这里是AP，那么也要采用延时双删的策略(同上)，
		5.删除数据的方式，有几种方案
			如果删除失败，那怎么办？
			方案1：那就采用重试机制，直到删除成功，这里可以采用消息队列实现重试机制。把消费失败的key放入队列，重新消费，直到成功
			方案2：采用订阅binlog的方式异步处理删除操作，也就是更新数据成功后，会把该操作记录再binlog中，利用阿里开源工具canal，读取binlog，将读取到的信息放入MQ中，然后通过ACK机制，来确认删除成功（ACK机制就是消费者消费消息后，会响应mq，然后mq从队列中删除该消息）
			方案3：（强一致性）实在不行那就串行化处理，把读请求和写请求放在一起，加锁处理，影响性能，不推荐，
		6.总结：
			无论是哪种方式，要么CP要么AP，要根据自己的业务场景，来决定使用哪种方式。而且对于写多的场景，实际上不太适合做缓存。
			1、一致性（Consistency）
			2、可用性（Availability）
			3、分区容错性（Partition tolerance）
			https://juejin.cn/post/6964531365643550751


⚫redis6.0为什么引入多线程？
多线程引入主要是为了解决删除大key或者释放内存，或者持久化时的io操作，等操作带来的性能问题。会阻塞主线程，所以引入多线程，可以减少主线程的阻塞提高性能，其实大多数操作还是主线程来完成的。
,Redis的瓶颈最有可能是机器内存的大小或者网络带宽，因为redis是内存操作所以速度非常块，并且采用多路复用的方式，可以监听多个io请求。所以这两个特点加起来，就可以使redis能够快速处理请求
