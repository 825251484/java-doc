⚫redis持久化：
1.RDB 方式（默认）：RDB方式是通过快照完成的（压缩的二进制文件），当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘
	1.触发RDB快照的时机
		1. 符合指定配置的快照规则
			save 900 1 ：表示15分钟（900秒钟）内至少1个键被更改则进行快照。
			save 300 10 ：表示5分钟（300秒）内至少10个键被更改则进行快照。
			save 60 10000 ：表示1分钟内至少10000个键被更改则进行快照。
		2. 执行sava或bgsave命令
		3. 执行flushall
		4. 执行主从复制操作
	2. 快照过程：
		1. Redis 调用系统中的 fork 函数复制一份当前进程的副本(子进程)
		2. 父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件。
		3. 当子进程写入完所有数据后会用该临时文件替换旧的 RDB 文件，至此，一次快照操作完成。
	3.注意事项：
		1. Redis 在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。
		2. 这就使得我们可以通过定时备份RDB文件来实现Redis数据库的备份， RDB文件是经过压缩的二进制文件，占用的空间会小于内存中的数据，更加利于传输。
	4.优缺点：
		优点：占用空间小，利于传输，子进程处理快照，不影响主线程
		缺点：一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据，

2.AOF 方式：redis执行增删改操作时，会把该命令写入磁盘中的aof文件中，这一过程会降低redis的性能。但大部分情况下这个影响是能够接受的，appendonly yes
	1.触发时机：
		1.appendfsync always  每次执行写入都会进行同步， 这个是最安全但是是效率比较低的方式
		2.appendfsync everysec  每一秒执行(默认)
		3.appendfsync no 不主动进行同步操作，由操作系统去执行，这个是最快但是最不安全的方式
	2.优缺点：
		1.文件保存的是命令。易于被人理解，采用always同步时，出现异常可以减少数据的丢失，但是性能不如rdb
		2.AOF文件体积变得过大时，自动地在后台对AOF进行重写： 重写后的新AOF文件包含了恢复当前数据集所需的最小命令集合，例如三条命令，只保存最后一条就可以了。set s1 11,set s1 22,set s1 33

3.混合持久化模式（4.0增加，5.0默认开启）
	因为RDB和AOF各有优缺点。为了弥补缺点。在redis4.0引入的了混合持久化方案。在写入的时候，先把当前的数据以RDB的形式写入文件的开头，再将后续的操作命令以AOF的格式存入文件，
	这样既能保证Redis重启时的速度，又能降低数据丢失的风险。开启参数:aof-use-rdb-preamble = yes或者配置文件修改redis.conf  Redis5.0默认值为yes。

4.注意：
	1.配置完成之后，需要重启Redis服务器，配置才能生效，但修改配置文件的方式，在每次重启Redis服务之后，配置信息不会丢失。需要注意的是，在非必须进行持久化的业务中，可以关闭持久化，这样可以有效的提升Redis的运行速度，不会出现间歇性卡顿的困扰。
	2.adb、rdb同时开启，只用aof
	3.持久化保证了即使Redis服务重启也不会丢失数据，因为Redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当Redis服务器的硬盘损坏了可能会导致数据丢失，不过通过Redis的主从复制机制就可以避免这种单点故障
	4.无论哪种持久化方案，都会丢失数据，只是AOF相对于丢失的少


⚫redis主从复制
	1.主从复制产生的原因：持久化保证了即使Redis服务重启也不会丢失数据，因为Redis服务重启后会将硬盘上持久化的数据恢复到内存中，
		但是当Redis服务器的硬盘损坏了可能会导致数据丢失，不过通过Redis的主从复制机制就可以避免这种单点故障
	2.主：不需要做任何配置  从：只需要配置一个参数：
		以前：slaveof
		后来：replicaof 主服务器ip:端口
	3.原理：
		1.从服务启动后，向主服务器发送psync命令。psync {runid} {offset} 
			- runid：从节点所复制主节点的运行id，注意：redis重启后runid会发生变化，当运行ID变化后从节点将做全量复制，也可以通过redis-cli debug reload保证重启后runid不变化
	　　　　- offset：当前从节点已复制的数据偏移量
		2.从节点发送psync命令给主节点，参数runid是当前从节点保存的主节点运行ID，参数offset是当前从节点保存的复制偏移量，如果是第一次复制偏移量则为-1。
　　　　3.主节点根据psync参数和自身数据情况决定响应结果：
	　　　　- 如果runid不一致 || 偏移量为-1，说明第一次复制，则回复 FULLRESYNC {runid} {offset}，那么从节点触发全量复制
	　　　　- 如果不是第一次复制，回复CONTINUE，从节点将触发部分复制流程
	　　　　- 如果回复ERR，说明主节点版本低于2.8，无法识别psync命令，从节点将发送旧版的sync命令触发全量复制流程。


⚫redis哨兵机制
	1.哨兵机制产生的原因：哨兵机制(Sentinel)主要是为了解决在主从复制架构中出现宕机的情况，由于这个手动完成恢复的过程其实是比较麻烦的并且容易出错,所以Redis提供的哨兵(sentinel)的功能来解决
	2.哨兵机制原理：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。
	3.哨兵机制定时监控：
		1.任务1：每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时只要配置对主节点的监控即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到
		2.任务2：每个哨兵节点每隔2秒会向redis数据节点的指定频道上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断
		3.任务3：每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测，这个也是哨兵用来判断节点是否正常的重要依据
	4.判断服务是否下线
		1.主观下线sdown：所谓主观下线，就是单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。SDOWN
		2.客观下线odown：当主观下线的节点是主节点时，此时该哨兵3节点会通过指令sentinel is-masterdown-byaddr寻求其它哨兵节点对主节点的判断，如果其他的哨兵也认为主节点主观线下了，则当认为主观下线
			的票数超过了quorum（选举）个数，此时哨兵节点则认为该主节点确实有问题，这样就客观下线了，大部分哨兵节点都同意下线操作，也就说是客观下线
	5.哨兵lerder选举流程：选出领导者进行故障转移
		1.每个在线的哨兵节点都可以成为领导者，当它确认（比如哨兵3）主节点下线时，会向其它哨兵发ismaster-down-by-addr命令，征求判断并要求将自己设置为领导者，由领导者处理故障转移；
		2.当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；
		3.如果哨兵3发现自己在选举的票数num 大于等于 (sentinels)/2+1时，将成为领导者，如果没有超过，继续选举…………
	6.故障转移机制
		1.选出主节点
			a. 过滤掉主观下线的节点
			b. 选择slave-priority优先级最高的节点，如果有则返回没有就继续选择
			c. 选择出复制偏移量最大的系节点，因为复制偏移量越大则数据复制的越完整，如果由就返回了，没有就继续
			d. 选择run_id最小的节点
		2.更新主从关系
			通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。
			将已下线的主节点设置成新的主节点的从节点，当其回复正常时，复制新的主节点，变成新的主节点的从节点
			同理，当已下线的服务重新上线时，sentinel会向其发送slaveof命令，让其成为新主的从



⚫redis集群Cluster
	在redis集群出现之前，使用Proxy+Replication+Sentinel方式做集群
	1.架构细接
		(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.
		(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.
		(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可
		(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster负责维护node<->slot<->value
	2.数据存放规则：
		Redis集群中内置了16384个哈希槽，当需要在Redis集群中放置一个key-value时，redis先对key使用crc16算法算出一个结果，然后把结果对16384求余数，
		这样每个key都会对应一个编号在0-16383之间的哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同的节点
	3.集群创建：
		创建节点：Redis集群最少需要三台主服务器，三台从服务器。端口号分别为：8001~8006
		创建集群：修改redis.conf配置文件，打开cluster-enable yes、 ./redis-cli --cluster create xxxxx
		连接集群：./redis-cli –h 127.0.0.1 –p 8001 –c （-c代表连接集群）
		查看集群状态：cluster info 、cluster nodes	
	主从切换流程：
		1. S先更新自己的状态，将声明自己为主节点。并且将S从M中移除
		2. 由于S需要切换为主节点，所以将S的同步数据相关信息清除（即不再从M同步锁数据）
		3. 将M提供服务的slot都声明到S中
		4. 发送一个PONG包，通知集群中其他节点更新状态
	集群伸缩容：
		扩容：
			添加主节点：./redis-cli --cluster add-node 新节点的ip:端口 现有集群ip:端口
			分配slot曹：./redis-cli --cluster reshard 集群任意节点 --cluster-from 源节点列表 --cluster-to 目标节点 slot数量
			添加从节点：./redis-cli --cluster add-node 192.168.133.22:8008 192.168.133.22:8007 --cluster-slave --cluster-master-id 
		缩容：
			收缩集群：1.首先删除master对应的slave、2.清空master的slot、3.下线（删除）节点
	集群容错：
		(1)节点失效判断：
			集群中所有master参与投票,如果半数以上master节点与其中一个master节点通信超过(cluster-node-timeout),认为该master节点挂掉.
		(2)集群失效判断:什么时候整个集群不可用(cluster_state:fail)?
			如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。
	集群优缺点：
		优点：
			1.无需Sentinel哨兵监控，如果Master挂了，Redis Cluster内部自动将Slave切换Master可以进行水平扩容支持自动化迁移，
			2.集群自动把多余的Slave迁移到没有Slave的Master中。（副本漂移）
		缺点：
			1.key的批量操作有限，目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key不被支持。
			2.key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能
			3.不支持多数据空间。单机支持16个数据库，集群只有db0 （Select命令切换库）
	注意：Cluster从机默认不读不写，就是备份和容灾，从机没有slot曹，集群中是没有sentinel，只是每个节点具备了监控其他节点的功能
		
