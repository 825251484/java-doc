⚫AOP底层原理 || @Transaction底层原理 || 拦截器原理？
1.首先会在创建bean的时候生成代理类。通过ProxyFactory代理工厂创建代理对象，并且会把增强类集合（拦截器链）放入代理工厂，默认使用JDK代理，如果配置了参数使用proxyTargetClass=true，但是目标类是接口或者继承Proxy，然后使用jdk代理，否则才使用cglib代理
2.在执行方法的时候，根据代理不同，会触发拦截器，拦截该方法，
	CGLIB代理时：
		CglibAopProxy类中的内部类DynamicAdvisedInterceptor#intercept方法，
			-> List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); // 获取拦截器链（从代理工厂中获取增强类集合（大家都叫拦截器链））
				-> new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy)  .proceed(); 
					1.第一部分：会执行CglibMethodInvocation构造器，同时在构造器内部调用父类的构造器（ReflectiveMethodInvocation.clsaa），初始化父类参数，把自增系数和拦截器链封装到父类中，（这里拦截器，包括前置、后置、异常通知等拦截器）
					2.第二部分：调用父类实例方法：proceed() // 这个方法中会递归执行每一个拦截器，，每执行一个拦截器自增系数+1，直到自增系数等于拦截器链的数量，递归结束。调用目标方法。
								这其中就包括TransactionInterceptor事务拦截器。该拦截器用来处理数据库的操作：开启事务，提交或者回滚事务
	JDK代理：同上述方法类似
		JdkDynamicAopProxy.invoke()，调用方法时会触发该方法，
			-> List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); // 获取拦截器链（从代理工厂中获取增强类集合（大家都叫拦截器链））
				-> invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
					-> retVal = invocation.proceed();
					该方法invoke()，直接初始化 new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain)对象，调用proceed()

也就是创建代理对象时，会注册拦截器获取该bean相关的拦截器。并创建拦截器，
通过AfterReturningAdviceAdapter、MethodBeforeAdviceAdapter、ThrowsAdviceAdapter都实现了AdvisorAdapter 类中的getInterceptor()方法（interceptors.add(adapter.getInterceptor(advisor));）
而该方法中就是通过new来创建三个拦截器：AfterReturningAdviceInterceptor、MethodBeforeAdviceInterceptor、ThrowsAdviceInterceptor（这三个拦截器实现了MethodInterceptor）
并且会传入一个Advice对象实例， 那么该实例就是在执行前置后置等处理时，调用的前置后置方法的实例、以下就是在proceed()执行时，执行前后置处理真正的拦截器中的逻辑

									advice
									   |
			  		(前置)BeforeAdvice			AfterAdvice(后置、异常)
						|						|
					MethodBeforeAdvice#before		 AfterReturningAdvice#after
			



相关文章：
https://zhuanlan.zhihu.com/p/383829479
https://www.cnblogs.com/chihirotan/p/7146586.html


⚫为什么@Transaction只对public修饰的方法生效？
	如果使用jdk代理：jdk本身只能代理实现接口的类，那么实现接口本身就是public abstract修饰的方法。
	如果是cglib代理：在执行代理时，会触发TransactionInterceptor事务拦截器执行invoke方法，该方法中调用invokeWithinTransaction() 
		-> tas.getTransactionAttribute(method, targetClass) 
			-> computeTransactionAttribute(method, targetClass);
				-> if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {return null;}
	该方法中对方法权限做了限制，我理解的是因为。private修饰本身就代理不了   protect：本身生成代理就是为了给其他类调用，而protect限制了权限，只能同胞或者子类调用，生成代理类就没有了意义，还有就是与jdk代理保持一致
