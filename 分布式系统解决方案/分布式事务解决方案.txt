⚫分布式系统和微服务的区别？
分布式系统是将一个系统，进行垂直拆分成若干个服务并独立部署。每个服务付责一个业务。例如将电商系统拆分成订单服务，库存服务，商品服务等
二微服务是更细粒度的拆分，比如将一个订单服务拆分成购物车服务，售后服务等等。


⚫CAP理论
CAP定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。
C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，
          那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。
A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。
          合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。
P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。

对于CP来说：放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。
对于AP来说：放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。


⚫为什么不能选择CA放弃P？
因为当发生网络分区问题时，我们无法保证可用性的同时，又保证数据的一致性。我们只能在可用性和数据一致性中间做选择


⚫BASE理论
BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。是对CAP中AP的一个扩展，就是AP的基础上，要保证数据的最终一致性
基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。
软状态：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。
最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。



⚫什么是分布式事务？
分布式事务就是在分布式系统中，服务与服务之间的调用要保持数据的一致性。要么全成功，要么全失败
官方：分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务  


⚫分布式事务三大场景
1.两个服务，每个服务有自己的数据库
2.一个服务，使用多个数据库
3.两个服务，使用一个数据库，只要跨jvm进程就会涉及分布式事务


⚫分布式事务解决方案：

⚫XA模式
定义：XA 协议是由 X/Open 组织提出的分布式事务处理规范，主要定义了事务管理器TM和局部资源管理器RM之间的接口。目前主流的数据库，比如 oracle、DB2 都是支持 XA 协议的。
  事务管理器TM：事务管理器作为全局的调度者，负责各个本地资源的提交和回滚
  本地资源管理器RM。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口（mysql5以后也实现了XA接口），
  mysql 从 5.0 版本开始，innoDB 存储引擎已经支持 XA 协议。

⚫2pc（二阶段提交--XA模式）
第一阶段：准备阶段(Prepare Phase)
          协调者(Coordinator)向所有参与者(Participant)发送Prepare请求
          每个参与者执行事务操作，但不提交
          参与者将执行结果(成功/失败)反馈给协调者

第二阶段：提交/回滚阶段(Commit/Rollback Phase)
          如果所有参与者都返回成功：
          协调者发送Commit请求
          参与者完成事务提交
          参与者返回ACK确认

          如果任一参与者返回失败或超时：
          协调者发送Rollback请求
          参与者回滚事务
          参与者返回ACK确认
问题：
   1、同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
   2、单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
   3、数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
   4、二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
2PC常用于数据库分布式事务，如：
          XA协议(如MySQL XA)
          Java EE中的JTA(Java Transaction API)
          一些分布式数据库系统          


⚫3pc
第一阶段：CanCommit阶段（询问阶段）
          协调者向所有参与者发送CanCommit请求
          参与者检查自身状态，判断是否可以执行事务
          参与者向协调者反馈响应(Yes/No)

第二阶段：PreCommit阶段（预提交阶段）
          情况1：所有参与者返回Yes
          协调者发送PreCommit请求
          参与者执行事务操作但不提交
          参与者记录Undo/Redo日志
          参与者向协调者反馈Ack响应

          情况2：任一参与者返回No或超时
          协调者发送Abort请求
          参与者中断事务

第三阶段：DoCommit阶段（提交阶段）
          情况1：协调者收到所有PreCommit Ack
          协调者发送DoCommit请求
          参与者完成事务提交
          参与者释放资源
          参与者向协调者反馈HaveCommitted响应
          
          情况2：协调者未收到全部PreCommit Ack
          协调者发送Abort请求
          参与者使用Undo日志回滚事务

3PC相对于2PC的改进：
1、引入超时机制：参与者在PreCommit阶段后长时间未收到DoCommit/Abort，会自动提交。协调者在发送PreCommit后故障，参与者会继续提交
2、减少阻塞时间：将2PC的准备阶段拆分为CanCommit和PreCommit两个阶段。在PreCommit阶段后，参与者已做好提交准备，降低了阻塞时间
3、降低单点故障影响：协调者故障后，系统仍能继续运行。参与者有超时提交机制，避免无限等待
网络分区问题：
1、如果出现网络分区，可能导致数据不一致
2、性能开销：比2PC多一次网络通信，性能有所下降
3、实现复杂度：比2PC更复杂，需要处理更多边界条件


⚫tcc模式
TCC（Try Confirm Cancel）方案是一种应用层面侵入业务的两阶段提交。是目前最火的一种柔性事务方案，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。
TCC分为两个阶段，分别如下：
第一阶段：Try（尝试），主要是对业务系统做检测及资源预留 (加锁，锁住资源，或者在表中添加字段，设置预留的资源，例如库存扣减，添加一个预留字段，try时设置字段值。第二阶段再对该字段处理)
第二阶段：本阶段根据第一阶段的结果，决定是执行confirm还是cancel（对第一阶段的预留字段进行提交。也就是真正的扣减库存，或者回滚库存）
          Confirm（确认）：执行真正的业务（执行业务，释放锁）
          Cancle（取消）：是预留资源的取消（出问题，释放锁）
TCC模式时完全依靠业务上的处理保证，数据的一致性，实现案例：
1.try阶段
          @Transactional
          public boolean try(){
            //冻结库存
            frozenStorage();
            //生成订单，状态为待确认
            saveOrder();
          }
 2.二阶段的confirm操作
          @Transactional
          public boolean confirm(){
              //释放掉try操作预留的库存
              cleanFrozen();
              //修改订单，状态为已完成
              updateOrder();
              return true;
          }

 3.二阶段的cancel操作
           @Transactional
          public boolean cancel(){
              //释放掉try操作预留的库存
              rollbackFrozen();
              //修改订单，状态为已完成
              delOrder();
              return true;
          }
TCC模式涉及的问题，和解决方案：
1、空回滚
定义：在未调用try方法或try方法未执行成功(异常时发生了回滚)的情况下，就执行了cancel方法进行了回滚。怎么理解呢？未调用try方法就执行了cancel方法，既然没有预留资源，那么肯定是不能回滚。
解决：解决逻辑很简单：在cancel方法执行操作之前，必须要知道try方法是否执行成功。
2、幂等性
定义：TCC模式定义中提到：如果confirm或者cancel方法执行失败，要一直重试直到成功。这里就涉及了幂等性，confirm和cancel方法必须保证同一个全局事务中的幂等性。
解决：解决逻辑很简单：对付幂等，自然是要利用幂等标识进行防重操作。
3、悬挂
定义：事务协调器在调用 TCC 服务的一阶段 Try 操作时，可能会出现因网络拥堵而导致的超时，此时事务管理器会触发二阶段回滚，调用 TCC 服务的 Cancel 操作，Cancel 调用未超时；
     在此之后，拥堵在网络上的一阶段 Try 数据包被 TCC 服务收到，出现了二阶段 Cancel 请求比一阶段 Try 请求先执行的情况，此 TCC 服务在执行晚到的 Try 之后，将永远不会再收到二阶段的        Confirm 或者 Cancel ，造成 TCC 服务悬挂。
解决：解决逻辑很简单：在执行try方法操作资源之前判断cancel方法是否已经执行；同样的在cancel方法执行后要记录执行的状态。
4、总结：针对以上三个异常，落地的解决方案很多，比如维护一个事务状态表，每个事务的执行阶段全部记录下来。

分布式解决方案SEATA
1.SEATA XA模式
   执行阶段：
          可回滚：业务SQL操作放在XA分支中进行，由资源对XA协议的支持来保证，可回滚
          持久化：XA分支完成后，执行XA prepare，同样由资源对XA协议的支持来保证持久化（即之后任何意外都不会造成无法回滚的情况）
   完成阶段：
          分支提交：执行 XA 分支的 commit
          分支回滚：执行 XA 分支的 rollback

2.SEATA AT模式（默认模式）
定义：AT，Automatic Transaction。 AT模式是Seata默认的分布式事务模型，是由XA模式演变而来的，通过全局锁对XA模式中的一些问题进行了解决。
自动清理回滚日志 ：当所有RM行执行完毕第二阶段的Global Commit后，AT模式能够自动以异步方式批量清理掉回滚日志，而XA模式不会清理，需要手动清理
角色：
Transaction Coordinator（TC）：事务协调器，它是独立的中间件需要独立部署运行，它维护全局事务的运行状态，接收TM指令发起全局事务的提交与回滚，负责与RM通信协调各各分支事务的提交或回滚。
Transaction Manager（TM）： 事务管理器，TM 需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向 TC 发起全局提交或全局回滚的指令。
Resource Manager（RM）：控制分支事务，负责分支注册、状态汇报，并接收事务协调器 TC 的指令，驱动分支（本地）事务的提交和回滚。
流程：
   一阶段：
          业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
   二阶段：
          提交异步化，非常快速地完成。
          回滚通过一阶段的回滚日志进行反向补偿。
与传统的XA模式不同：
   多了一个TC角色，传统提交和回滚都是又TM来负责，其中日志数据和回滚数据的记录都是由数据库厂商来实现，然后TM来才做这些数据。
   而SEATA AT是TC来负责提交回滚，由SEATA服务来实现，数据的备份和日志的记录等功能。undo_log表
SEATA中的XA和AT：
   SEATA中的XA和AT模式都是基于二阶段提交来实现的，从编程模型上，XA模式与AT模式保持完全一致。两者在使用上，只需要修改数据源代理，即可实现 XA 模式与 AT 模式之间的切换
         
3.SEATA TCC模式
4.SEATA SAGA长事务模式
参考连接：https://seata.io/zh-cn/docs/dev/mode/tcc-mode.html
