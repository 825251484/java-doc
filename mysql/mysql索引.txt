⚫mysql索引分类
主键索引：索引列中的值必须是唯一的，不允许有空值。
普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。
唯一索引：索引列中的值必须是唯一的，但是允许为空值。
全文索引：只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。
		  全文搜索时候，全文索引一般很少使用，数据量比较少或者并发度低的时候可以用。但是数据量大或者并发度高的时候一般是用专业的工具lucene,es，solr
		  可以使用MATCH() SELECT * FROM t_fulltext WHERE MATCH(content) 1 AGAINST('开课吧');
空间索引：用来存储地理位置经纬度
前缀索引：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。ALTER TABLE table_name ADD INDEX index_name (column1(length));
组合索引：使用2个以上的字段创建的索引。


⚫索引字段太长怎么解决
可以使用前缀索引。使用字段的前几个长度创建索引，但是长字段本身就不适合做索引。所以前缀索引也比较少使用


⚫mysql索引的数据结构有哪些？
索引的数据结构至少要支持两种最常用的查询需求：等值查询，范围查询，其次支持：排序分组等
1.hash表：结构类似于map，适合用在等值查询，根据key查询value。key是索引列，value是数据行对应的磁盘地址，时间复杂度是O(1)，但是不支持范围查找，范围查找需要全表扫描
2.二叉查找树（红黑树）：坏的情况下，会退化成单向链表，导致全表扫描
3.平衡二叉查找树：左右子树相差层级最多是1，插入删除数据可以通过左旋右旋保持树的平衡。时间复杂度是O(logn),类似于二分查找法
	缺点：每个节点读取对应一次磁盘io，如果数据量很大，导致树的高度很高，那就需要就行很多次磁盘io，查找性能会很差，而且范围查找需要从根节点遍历很多次，也很耗时
4.B树：
	问题分析：为了减少磁盘io的次数，那么我们可以考虑在平衡二叉树的基础上优化，降低树的高度，并且在一次磁盘的io中（16k）尽可能的查询多的数据，所以诞生了B树：多叉平衡树，
	特点：每个节点保存多个元素，每个元素包含主键和数据，每个节点保存元素的上限叫度，每个元素的两边各有一个指针指向下一个节点，左边元素小于根节点，右边元素大于等于根节点
	问题：因为每个元素中包含主键和数据，如果数据行很大，一次磁盘io一个节点16k，那么每个节点只能保存很少的元素。这样就会造成树的高度很高。并且范围查询一样会从根节点遍历
5.B+树（改造B树）
	问题分析：为了解决上面b树的问题，
	特点：每个节点保存多个元素，每个元素只保存主键，不保存数据，所有数据只保存在叶子节点中，每个叶子节点通过双向指针连接，这样可以大大降低树的高度，减少磁盘io，并且叶子节点有双向指针，在范围查找时，不需要再从根节点遍历
	
	
⚫MyIsam和InnoDB索引存储结构
1.MyIsam
	主键索引：叶子节点存储的是主键和对应数据行的指针，通过叶子节点的指针查找数据行时也需要一次磁盘io
	非主键索引：同主键索引

2.InnoDB
	主键索引：叶子节点存储的是，主键和对应的数据行，根据主键索引查询效率高于MyIsam引擎。主键索引和数据行是聚集存储在一起，所以叫做聚集索引或者聚簇索引。
	非主键索引：叶子节点中保存的是主键。如果查询数据需要根据辅助索引找到对应的主键信息，然后根据主键查询找到对应的叶子节点的行记录。这个查询主索引的过程叫做：回表。如果使用辅助索引查询的话效率比MyIsam引擎要低。


⚫组合索引的特点及注意事项
组合索引：一个索引中包含多个字段。
注意事项：
	1.全值匹配我最爱，最左前缀要遵守；
            编写SQL查询条件时最好是等值查询。如果是等值查询查询条件中的多个字段都可以应用索引。
            如果使用范围查询(<,>,between,like)或者不等于查询条件导致后面的条件不能应用索引。（范围查询后将导致下一个字段变成无序，会扫描全部）
			如果组合索引顺序不对，那么musql优化器也会进行顺序优化，优化成索引可以识别的形式
        2.带头大哥不能死，中间兄弟不能断；
            查询条件中第一个字段必须存在，如果不存在不能应用组合索引。中间字段如果缺失，导致后面的字段都无法应用索引。
        3.索引列上不计算，范围之后全失效；
            如果查询条件中包含字段的计算或者字符串截取。或者隐式数据类型转换导致索引失效，字段的数据类型和传入值的数据类型不一致，也会导致索引失效
                例如:where (a+1) = 10
        4.Like百分写最右，覆盖索引不写星；
            使用like查询时也可以应用索引，要求“%”不能出现在最左边
                可以应用索引的案例：
                    where name like '章%'
                不可以应用索引：
                    where name like '%章'
                    where name like '%章%'
        5.不等空值还有OR，索引失效要少用。
            is null相当于等值查询，是可以应用索引的。
            is not null或者or相当于范围查询，所以会导致索引失效。
使用方法：
	1.频繁出现在where条件中的字段建议创建组合索引。
        2.频繁出现在order by和group by语句中的列，建议按照顺序去创建组合索引。order by a,b 需要组合索引列顺序（a,b）。如果索引的顺序是（b,a），是用不到索引的。
			面试题：select * from t where a=1 1 and b>2 order by c SQL语句除了建ab联合索引，还有更好的方案吗？
				答案：可以考虑建立 （a,c）联合索引：select * from xxx where a=1 and b>2 order by c 这样a等值查询 c就是已经排好序的了。
					  这种情况实际上比较的是b的区分度和c的区分度，如果b的区分度比较差，建议使用ac。如果c的区分度比较差，建议使用a,b。
        3.频繁出现在select语句中的字段也可以考虑添加到组合索引中。-----覆盖索引
		4.多表join关联查询，on字段两边的字段都要创建索引
		
		
⚫覆盖索引
    在select后把查询的字段列出，如果查询的字段在辅助索引中都包含，不需要回表，可以提高查询速度。就叫做覆盖索引。


⚫索引条件下推（ICP）
    说明：官方索引条件下推： Index Condition Pushdown,简称ICP。是MySQL5.6对使用索引从表中检索行的一种优化。可以通过参数optimizer_switch控制ICP的开始和关闭。索引下推（Index Condition Pushdown, ICP）是一种数据库查询优化技术，它允许数据库引擎在使用索引检索数据的同时，将部分WHERE条件下推到存储引擎层进行过滤，而不是在服务器server层才进行过滤
    注意：对于InnoDB表ICP仅用于辅助索引。非索引字段一律在server层过滤
	原理：
		不使用ICP，不满足最左前缀的索引条件的比较是在Server层进行的，非索引条件的比较是在Server层进行的。
		使用ICP，所有的索引条件的比较是在存储引擎层进行的，非索引条件的比较是在Server层进行的。
		就是说即使使用范围查询，那么范围查询之后的索引字段，同样在引擎层过滤，过滤之后回表的数据就很少了，返回给server层更少了。
		不使用icp，失效的索引在引擎层不会过滤掉，那么剩下的数据都会回表，然后把回表的数据行返回给Server层再过滤，这就导致返回给Server层的数据更多了
			比如，不使用icp的情况，使用复合索引abc，当我查询时使用了ac查询，那么在引擎层是通过a查询数据，然后在根据id回表查询所有满足a的数据，然后返回给server层，server层在根据c过滤一遍。
			当使用icp时，ac会在引擎层过滤，在根据id回表，再返回给server层，server层不用任何过滤。
	优点：
		对比使用ICP和不使用ICP，可以看到使用ICP可以有效减少回表查询次数和返回给服务层的记录数，从而减少了磁盘IO次数和服务层与存储引擎的交互次数。
		原来无法应用索引的条件，可以在引擎层进一步筛选，向server层返回更少的结果集。提高查询效率。


⚫mysql优化器做了哪些事情
1、外链接转连接
2、最有索引选择：索引条件放在前面，提前过滤更多数据，优化连接顺序
3、多表连接优化
4、条件过滤下推，决定哪些条件可以下推到存储引擎(ICP)，将HAVING条件下推为WHERE条件，正常来说HAVING和ORDER BY是在server层过滤，使用icp可能下推到引擎层
5、ORDER BY还有HAVING是在引擎层过滤还是server层过滤：ORDER BY和HAVING正常是在server层过滤
	当使用索引完全覆盖排序时，ORDER BY时在引擎层过滤，部分HAVING条件可下推为WHERE条件
存储引擎：WHERE条件（部分通过ICP）、索引扫描/全表扫描
Server层：JOIN操作、GROUP BY、HAVING、ORDER BY、LIMIT


	
⚫索引优化建议
1. 表记录很少不需创建索引 （索引是要有存储的开销）.
2. 一个表的索引个数不能过多。
	（1）空间：浪费空间。每个索引都是一个索引树，占据大量的磁盘空间。
	（2）时间：更新或插入变慢。需要更新所有的索引树。太多的索引也会增加优化器的选择时间。所以索引虽然能够提高查询效率，索引并不是越多越好，应该只为需要的列创建索引。
3. 频繁更新的字段不建议作为索引。频繁更新的字段引发频繁的页分裂和页合并，性能消耗比较高。
4. 区分度低的字段，不建议建索引。（仅供参考）
	比如性别，男，女；比如状态。区分度太低时，会导致扫描行数过多，再加上回表查询的消耗。如果使用索引，比全表扫描的性能还要差。这些字段一般会用在组合索引中。姓名，手机号就非常适合建索引。
5. 在InnoDB存储引擎中，主键索引建议使用自增的长整型，避免使用很长的字段。
	主键索引树一个页节点是16K，主键字段越长，一个页可存储的数据量就会越少，比较臃肿，查询时尤其是区间查询时磁盘IO次数会增多。辅助索引树上叶子节点存储的数据是主键值，主键值越长，一个页可存储的数据量就会越少，查询时磁盘IO次数会增多，查询效率会降低。
6. 不建议用无序的值作为索引。例如身份证、UUID
	更新数据时会发生频繁的页分裂，页内数据不紧凑，浪费磁盘空间。
7. 尽量创建组合索引，而不是单列索引。
	优点：
	（1）1个组合索引等同于多个索引效果，节省空间。
	（2）可以使用覆盖索引
	创建原则：组合索引应该把把频繁的列，区分度高的值放在前面。频繁使用代表索引的利用率高，区分度高代表筛选粒度大，可以尽量缩小筛选范围。
	

⚫sql语句优化建议
1.将筛选粒度大的查询条件放到最左边
2.尽量使用覆盖索引，SELECT语句中尽量不要使用*。
3.索引长度尽量短，短索引可以节省索引空间，使查找的速度得到提升，同时内存中也可以装载更多的索引键值。太长的列，可以选择建立前缀索引
3.索引更新不能太频繁，
4.order by 要保持顺序，并且多条个字段时，排序规则要一致
5.limit优化：偏移量多大，查询效率越低。解决：单表查询时，可以使用主键排序，然后使用where id > 10000,然后再取limit 0,10，如果非主键索引查询，那么先走非主键索引查询主键（覆盖索引），再通过in主键查询行数据（主键索引，回表）
6.小表驱动大表，两个表做关联查询时建议使用join ，因为使用left join 的话。现代MySQL优化器(5.7+)会自动决定最佳连接顺序
7.避免使用不等于（!=,<>），或者not in 查询，相当于范围查询，范围查询之后的条件会导致索引失效
8.关联字段简历索引



⚫实际开发中sql优化经验：
1、根据业务含义，尽量将字段都添加上NOT NULL DEFAULT VALUE属性，如果列值存储了大量的NULL，会影响索引的稳定性。
2、对于默认字段created_at(create_time)、updated_at(update_time)这种默认就应该创建索引，这一般来说是默认的规则。
3、对于变长字符串类型varchar(m)，为了减少key_len，可以考虑创建前缀索引，但是前缀索引不能消除group by， order by带来排序开销
4、不建议使用Text数据类型，表上的DML操作都会变的很慢，建议采用es或者对象存储OSS来存储和检索。
5、使用关联查询代替子查询。
	1）相关子查询：SELECT * FROM A WHERE a.id IN (SELECT b.a_id FROM B WHERE b.col=A.col)，对外部查询的每一行执行一次，若外部有100行，子查询可能执行100次
	2）非相关只查询：SELECT * FROM A WHERE a.id IN (SELECT b.a_id FROM B WHERE b.col='value')，只执行一次，结果被缓存，无论外部查询多少行，子查询只执行1次
6、尽量用内连接代替左外连接。因为左外连接会返回左表所有的数据。而内连接只返回关联的数据。数据量小。那么磁盘io次数就会减少。
7、对于分页查询的优化：因为分页函数limit(a,b)，第一个参数越大，那么查询性能越差，所以可以先分页只查出id。然后用id关联原表查询。因为分页查询中使用了索引覆盖，只扫描索引树中的主键id即可。然后关联id查询。
8、内连接中on和where作用一样
   外连接中不一样：
	on：以左表为基础。过滤调右表的数据。返回的还是左表的数据行数。之后字段为空！
	where：先把外连接的数据生成中间表。然后再对中间表的数据进行过滤。那么返回的行数是小于等左表的
9、也可以建立冗余字段，防止表关联带来的性能开销，例如订单表。冗余：商品个数，支付状态。发货状态等等。


⚫mysql性能优化思路
1. 首先需要使用【慢查询日志】功能，去获取所有查询时间比较长的SQL语句：日志中会记录查询时间。连接信息，等待表锁的时间，返回的行数，查询检查的行数，还有具体的sql包括增删改查都会记录
	【slow_query_log】 ：是否开启慢查询日志，1为开启，0为关闭。【long_query_time】 ：慢查询阈值。mysqldumpslow工具可以查询赛选慢查询日志中的sql语句，帮助我们快速定位问题，mysql自带的工具
2. 查看执行计划，查看有问题的SQL的执行计划：EXPLAIN 命令
3. 针对查询慢的SQL语句进行优化：
4. 使用【show profile[s]】 查看有问题的SQL的性能使用情况，包括增删改查
	MySQL 5.0.37以及以上版本中才有实现，通常我们是使用的explain,以及slow query log都无法做到精确分析，
	但是Query Profiler却可以定位出一条SQL语句执行的各种资源消耗情况，比如CPU，IO等，以及该SQL执行所耗费的时间等：show variables like '%profil%'; set profiling=1 1; --1是开启、0是关闭
	show profile: 展示最近一条语句执行的详细资源占用信息，sql执行过程，任何一个环节所占用的时间，
	show profile cpu,1 swaps for query 2; 还可以添加一些参数查询具体的sql使用情况
5. 调整操作系统参数优化
6. 升级服务器硬件


⚫explain命令解析
id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.
select_type: 单位查询的查询类型，比如：普通查询、联合查询(union、union all)、子查询等复杂查询。
table: 查询的是哪个表，可能是null或者是临时表
partitions: 匹配的分区，mysql数据在一个表中，但物理存储根据一定的规则放在不同的文件中。
type: 代表索引的使用情况，访问性能依次从好到差，最少要使用到range级别，除all之外，其他的type都可以使用到索引，除index_merge之外，其他的type只可以用到一个索引
	system：表中只有一行数据，或者是空表，这是const特例，平时不会出现
	const：使用唯一索引或者主键查询到一条数据，等值查询返回一条记录：where id = 1
	eq_ref：使用唯一索引，表中只有一条记录与之匹配：select * from a left join b on a.id = b.id  b表中就是eq_ref
	ref：非唯一索引、组合索引，返回多条符合条件的数据行
	fulltext：全文索引，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引
	ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多
	unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值
	index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重
	range：索引范围扫描，常见于使用>,<,is null,between ,in ,like等运算符的查询中。 注意：使用in查询时，一定会使用索引，但是如果查询结果返回大多数数据行，那么就会全表扫描
	index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，
	index：全部索引扫描，把索引从头到尾扫一遍
	ALL：全表扫描
possible_keys: 此次查询中可能选用的索引，一个或多个
key: 查询真正使用到的索引
key_len：索引长度
ref: 哪个字段或常数与key一起被使用
rows: 这里是执行计划中估算的扫描行数，不是精确值
filtered: 存储引擎层返回的结果中包含有效记录数的百分比。最大值为100，这意味着没有对行进行筛选。
extra: 额外的信息
	Using temporary使用临时表保存中间结果
	Using index查询时不需要回表查询，就可以获得结果
	using where 表示存储引擎返回的行需要在服务器层进一步过滤
	using filesort 表示需要额外的排序操作，无法利用索引的有序性
	Index Condition Pushdown使用索引条件下推


⚫服务器层面优化
1.缓存区优化：将数据保存在内存中，保证从内存读取数据，建议innodb_buffer_pool_size1 设置为总内存大小的3/4或者4/5.
2.磁盘写入次数优化：对于生产环境来说，很多日志是不需要开启的，比如：通用查询日志、慢查询日志、错误日志
3.mysql数据库配置优化

