⚫mysql有哪些日志文件?
MySQL是通过文件系统对数据和索引进行存储的：
	1.错误日志：错误日志记录了运行过程中遇到的所有严重的错误信息,以及 MySQL每次启动和关闭的详细信息。
	2.二进制日志（binlog）：binlog主要用于实现mysql主从复制、数据备份、数据恢复
	3.查询日志：默认情况下通用查询日志是关闭的。由于通用查询日志会记录用户的所有操作，其中还包含增删查改等信息，在并发操作大的环境下会产生大量的信息从而导致不必要的磁盘IO，会影响mysql的性能的。如若不是为了调试数据库的目的建议不要开启查询日志。
	4.慢查询日志：默认是关闭的，记录执行时间超过long_query_time秒的所有查询，便于收集查询时间比较长的SQL语句。查询多少SQL超过了慢查询时间的阈值： SHOW GLOBAL STATUS LIKE '%Slow_queries%';
	5.重做日志（redo log）：当InnoDB的数据存储文件发生错误时，重做日志文件就能派上用场。InnoDB存储引擎可以使用重做日志文件将数据恢复为正确状态，以此来保证数据的正确性和完整性。
	6.回滚日志（undo log）：多版本的数据快照。
	7.中继日志（relay log）：主从复制
	
⚫mysql数据文件：
1）InnoDB数据文件
	.frm文件：主要包括表结构的定义信息
	.ibd：InnoDB引擎存储数据的文件。其中包含数据和索引信息
	ibdata文件：系统的元数据详细，系统的数据。
2）MyIsam数据文件
	.frm文件：主要存放与表相关的数据信息,主要包括表结构的定义信息
	.myd文件：主要用来存储表数据信息。
	.myi文件：主要用来存储表数据文件中任何索引的数据树。
	
⚫查看系统参数及状态
1、查看系统参数
	show variables like '%xxxx%';
2、查看系统状态
	show status like '%xxxx%';


⚫mysql架构
1、server 层
	1）连接器：Connectors
		维护和客户端的连接的连接池。
	2）分析器：Parser:
		SQL语句。对SQL语句进行词法分析语法分析。
	3）优化器：Optimizer
		对分析结果进行优化。
	4）执行器
		把优化结果交给数据库引擎执行。
	5）查询缓存
		在内存中建立一个缓存系统。key-value形式
		key：sql语句
		value：对应结果集。
		默认关闭状态，在msyql8中缓存模块已经删除了。

		缓存的优点：
			提高查询性能
		缓存的缺点：
			1.建立缓存，时间开销。
			2.空间开销。
			3.缓存维护的时间开销。
			4.在并发高的系统中，缓存的命中率可能不高。
		当相同的sql语句反复执行时，可以使用缓存。

		使用方法：
			缓存是通过“query_cache_type”来控制。
			mysql> show variables like 'query_cache_type';
			+------------------+-------+
			| Variable_name    | Value |
			+------------------+-------+
			| query_cache_type | OFF   |
			+------------------+-------+
			1 row in set (0.00 sec)
		开启缓存：
			在/etc/my.cnf配置文件中设置“query_cache_type”的值
				0：关闭缓存
				1：开启缓存，默认缓存所有的select语句。“select sql_no_cache xxx”
				2：可以有针对性的对SQL语句进行缓存。只缓存“select sql_cache xxx”
		查看缓存的命中率：
			show status like 'qcache_hits';

2、引擎层
	查看mysql默认的引擎列表：show engines;
	除非需要用到某些InnoDB不具备的特性，并且没有其他办法可以替代，否则都应该选择InnoDB引擎。
	引擎的选择：不同的表可以使用不同的引擎，需要在创建表的时候指定使用何种引擎。


⚫MySQL存储引擎种类
myisam：高速引擎，拥有较高的插入，查询速度，但不支持事务
innodb：5.5版本后MySQL的默认数据库，支持事务和行级锁定，比MyISAM处理速度稍慢
memory：内存存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失


⚫Innodb和Myisam的区别
		Innodb		Myisam
锁		表锁行锁	表锁
事务	支持		不支持
CRDU 	读、写		读多
count 	扫表		专门存储的地方
索引	B+Tree 	B+Tree


⚫Innodb结构
1、磁盘结构
	1）系统表空间（ibdata1文件）
		用户字典、双写缓冲区、修改缓冲区、回滚日志undolog。
		mysql> show variables like 'innodb_data_file_path';
		+-----------------------+------------------------+
		| Variable_name         | Value                  |
		+-----------------------+------------------------+
		| innodb_data_file_path | ibdata1:12M:autoextend |
		+-----------------------+------------------------+
	2）用户表空间
		默认每个表都对应一个用户表空间，保存是表中的数据和索引信息。
		mysql> show variables like 'innodb_file_per_table';  on:默认 off：所有的数据都放到系统表空间中
		+-----------------------+-------+
		| Variable_name         | Value |
		+-----------------------+-------+
		| innodb_file_per_table | ON    |
		+-----------------------+-------+
		用户表空间的存储格式
			ibd文件->段->区->页（基础单位）->行（数据行），MySQL中对数据的读写是以“页”为单位，每个数据页默认是16k。行的大小取决于表结构的定义。如果数据行定义超过16k，存储时需要使用多个数据页进行存储。（不建议）
	3）通用表空间
		需要通过create tablespace语句创建的。一般不需要的。
	4）临时表空间
		当mysql使用到临时表时会自动创建。
	5）回滚表空间
		默认是在系统表空间中。
	6）重做日志（redo log）
		由一组文件组成：
		ib_logfile0
		ib_logfile1
		采用循环写的模式使用这一组文件。写满后会覆盖最旧的日志
		| innodb_log_file_size        | 50331648 |
		| innodb_log_files_in_group   | 2 
2、内存结构
	1）buffer poll 缓冲池
		其中包含数据页和索引页。读写都是以页为单位。
	2）修改缓冲区（插入缓冲区）
		其中保存的是辅助索引（非主键索引和非唯一索引）的缓冲区。当修改数据时，对应的辅助索引也修改对应的修改。
		先对辅助索引的修改放到缓冲区，然后慢慢的处理。
	3）自适应hash索引
		由InnoDB自己来维护的一个hash索引，用户无法干预。
	4）log buffer
		redo log的缓冲区。
		

⚫InnoDB数据更新流程
	1）分配事务ID（trx_id），创建read view（如果是可重复读隔离级别）
	2）通过B+树索引定位到目标记录，如果数据页不在缓冲池(Buffer Pool)中，从磁盘加载到内存
	3）对记录加行锁（X锁），如果涉及间隙则加间隙锁（取决于隔离级别）
	4）生成undo记录(内存中)
	5）记录undo页修改到redo log buffer
	6）修改内存中的数据页(变脏页)
	7）记录数据页修改到redo log buffer
	8）生成binlog事件(Server层)
	9）redo log刷盘(prepare阶段，强制刷盘)
	10）binlog刷盘
	11）redo log刷盘(commit阶段，只修改状态)
	12） 脏页刷盘(延迟)


⚫为什么不能先写脏页？
违反WAL原则：日志先行原则，日志先于数据落盘
如果先写脏页后写日志，崩溃时将无法恢复，可能造成部分写入的数据无法回滚
原子性破坏：未提交的事务的数据已经落盘，事务可能提交失败，但是数据已经写入。


	redo log 文件顺序写，效率比随机写效率高。
	如果系统突然崩了，可以根据redo log 中的日志信息，恢复数据。redo log中记录的是数据页中的什么位置修改什么内容。
	redo log 也就是保证数据完整性的重要环节。

	脏页：随机写，修改buffer pool中的数据页后，造成内存中的数据页和磁盘上的数据页内容不一致，形成脏页。脏页指的是内存中数据页。
	buffer pool 采用LRU算法进行数据页的调度。
	

⚫脏页落盘的时机
	采用CheckPoint检查点机制

	1）sharp checkpoint：强制落盘。把内存中所有的脏页都执行落盘操作。关闭数据库之前执行。
	2）fuzzy checkpoint：模糊落盘。把内存中一部分脏页执行落盘操作。
		1、Master Thread Checkpoint
			主线程定时将脏页写入磁盘。每秒或者每10秒一次的频率。
		2、FLUSH_LRU_LIST Checkpoint
			buffer pool有脏页换出，需要执行checkpoint。
		3、Async/Sync Flush Checkpoint
			redo log快写满的时候执行checkpoint。
			当redo log 文件占用空间超过75%小于90%，会执行异步落盘操作。不会阻塞写操作。
			当redo log 文件占用空间超过90%，会执行同步落盘操作。会阻塞写操作。
		4、Dirty Page too much Checkpoint
			buffer pool中脏页太多，如果脏页率超过75%执行checkpoint。
			
			
⚫双写落盘
	1、把写入的数据页放到内存的双写缓冲区（2m）
	2、把内存中缓冲区的数据页写入系统表空间的双写缓冲区。
	3、把内存中缓冲区的数据页写入用户表空间。

	崩溃恢复：
		1）如果系统表空间数据页写坏。可以根据用户表空间的原始数据页+redolog 恢复数据。
		2）如果用户表空间数据页写坏。可以使用系统表空间中最新的数据页恢复数据。
		
		
⚫redo log落盘控制参数
	innodb_flush_log_at_trx_commit=1
	当属性值为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入每秒写入一次；
	当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；
	当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用fsync，而是让文件系统自己去判断何时将缓存写入磁盘。


⚫修改缓冲区的作用：是InnoDB存储引擎中一个重要的内存结构，主要用于优化非唯一二级索引的写操作性能。
存储内容：存储增删改的非唯一二级索引页的变更
特点：仅缓存非唯一二级索引，延迟合并机制，是缓冲池(Buffer Pool)的一部分（默认最多占用缓冲池的25%(可通过参数调整)）
注意：此动作也会写入redolog，如果出现崩溃，可通过redo恢复。
关于主键索引和唯一索引：都在Buffer Pool中进行，聚簇索引包含完整行数据，必须保证数据一致性，任何DML操作都必须访问聚簇索引，必须立即读取索引页来验证唯一性，无法延迟更新，因此不能使用修改缓冲区。处理流程：先检查唯一性约束，然后更新索引记录，如果索引页不在缓冲池，必须从磁盘加载


⚫双写缓冲区的作用：是InnoDB存储引擎中一个关键的安全机制，主要用于防止"部分页写入"(Partial Page Write)问题，确保数据页写入的原子性和一致性
存储内容：内存：位于InnoDB缓冲池(Buffer Pool)中的一个内存区域，作为数据页写入磁盘前的临时中转区。磁盘：位于系统表空间(ibdata文件)中的固定区域，由连续的128个页(默认2MB)组成
工作流程：
	1、当脏页需要刷新到磁盘时，先被复制到内存中的双写缓冲区
	2、数据页首先被顺序写入磁盘上的双写缓冲区区域，然后再写入实际的数据文件位置
	3、如果发生部分页写入(partial page write)，可以从双写缓冲区恢复完整页
解决什么问题：当数据库发生崩溃或断电时，可能只完成了数据页的部分写入（如16KB的页只写了8KB），这种损坏的页无法通过redo log恢复（因为redo log基于完整页的变更）
部分页写入的问题，为什么不能用redolog恢复？
	1、当发生部分页写入时（如16KB的页只写了8KB），问题不在于redo log本身，而在于磁盘上的数据页处于物理损坏状态，这种损坏超出了redo log的设计解决范围。
	2、redo log应用必须基于一个完整的、逻辑一致的数据页，重放对完整页的修改
	3、无法定位正确的修改位置：页头元信息可能损坏，redo log无法验证页的完整性


⚫mysql事务原理：同更新流程包含事务的原理

