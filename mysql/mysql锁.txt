⚫mysql ACID实现机制
1、原子性(Atomicity)：原子操作，提交/回滚
2、一致性(Consistency)：主键/唯一/外键约束
3、隔离性(Isolation)：
	四种隔离级别：
		读未提交(RU)：直接读取最新版本
		读已提交(RC)：每次读创建新ReadView
		可重复读(RR)：事务首次读创建ReadView
		串行化(S)：所有读操作加共享锁
4、持久性(Durability)：日志先于数据落盘，日志二阶段提交



⚫什么是MVCC？有什么作用？
是一种多版本并发访问控制技术，为了解决不同事务之间的隔离性的问题，解决脏读和不可重复的问题（脏读是通过锁解决的）。并且在mysql中只有RC和RR才支持mvcc，mysql中的MVCC实现主要依赖undolog和readview，
undolog中存储的是每条记录更新（update、delete操作）的版本链，在每一行数据中有两个隐藏字段，一个是事务id，全局唯一，一个是回滚指针，指向上一个版本的数据行。
readview是一个对象，其中有几个参数，一个是存储活跃的事务id的有序数组m_ids，一个是上限值：指的是数组中最大的事务的下一个事务，还有一个下限值指的是数据中最小的事务id，
如果undolog中被访问的版本的事务id小于下限值，那么说明，在生成readview之前该事务已经提交了，所以该版本可以被当前事务访问，
如果大于等于最大值，说明被访问的事务是在生成readview之后创建的事务，所以该版本不可以被访问，
如果在上限与下限值中间，并且等于数组中的一个值，那么代表该版本是一个活跃的版本。所以不可以被访问，如果被访问的版本的事务id 在区间内。但是没有相等的值，那么代表该版本已经提交了，所以该版本可以被访问


⚫为什么其他两个隔离级别都和MVCC不兼容？
因为READ UNCOMMITIED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。


⚫不可重复读，幻读，脏读
不可重复读：针对同一行的多次读取结果不一致 -- 读未提交，读已提交
幻读：针对范围查询的结果集数量变化。-- 读未提交，读已提交，在可重复读(RR)级别可能出现
脏读：读取到其他事务未提交的数据 -- 读未提交



⚫那么mvcc是怎么防止RR级别中不可重复读的问题的呢？
RC的隔离级别中：在每次读取数据时，都会生成新得readview，这么已经提交过的更新请求就是一个可见的版本，或者提交过的插入请求也是一个可见的版本。那么在同一个事务中，每次查询读取都会生成一个新的readview，这就是导致RC级别下的不可重复读和幻读的原因，
那么在RR级别中为了防止不可重复读。就是在同一个事务中多次读取数据时，只有在第一次读取数据时会生成一个readview，之后将不在生成新的readview，所以并不会读取到新的可见版本


⚫快照读和当前读的区别
快照读：读取的是当前版本链中可见的版本下的数据，有可能是历史版本。不需要加锁，就是普通读
select * from table 

⚫当前读：读取的是最新的版本记录，并且都会加上锁，保证其他事务不会并发修改这条记录
select * from table where ? lock in share mode;
select * from table where ? for update;
insert into table values (…);
update table set ? where ?;
delete from table where ?;

⚫mysql的RR隔离级别是怎么防止幻读的，一定程度上防止幻读
幻读：在同一个事务中两次读取的数据不一致。--增删操作
RR级别中可以防止一定程度的幻读，首先幻读分两种，
快照读中的幻读：是通过MVCC控制的，在同一个事务中多次读取数据时，只有在第一次读取数据时会生成一个readview，即使别的事务插入/删除已经提交了，但是对于该事务是不可见的，查到的还是以前的数据。
但是其实数据库中数据已经发生变化。如果你在当前事务中做当前读操作，就会读出该数据，出现幻读的问题
当前读中的幻读：是通过记录锁GAP来解决幻读的，当前读就是在读取数据时加读锁或者写锁，那么加锁时，会在记录上添加记录锁 在记录与记录中间添加间隙锁。可以防止其他事务对对该记录的新增和修改
比如A线程做当前读操作，主键是1，条件是where name = “aa” ，那么B线程插入一条主键是2，name =‘aa’的记录并提交事务，其实B事务提交不了，就是因为加了间隙锁，防止出现幻读


⚫锁的分类及特点
一、MySQL的锁的分类
	1、粒度分类
		全局锁：锁定整个mysql实例。
		表级锁：锁定某一个表。
		行级锁：对某一行数据加锁。只有InnoDB引擎支持。
	2、功能分类
		X锁（写锁）：排它锁
		S锁（读锁）：共享锁
二、全局锁
	锁定整个mysql实例，mysql处于只读状态。
	1.加锁
		mysql> flush tables with read lock;
	2.解锁
		mysql> unlock tables;
		回话断开自动解锁。

三、表级锁
	1.共享锁（S锁）
		SessionA加锁之后，表处于只读的状态。其他会话可以读取表中的数据，
		不能修改，SessionA也只能读取不能修改。
		加锁：
			lock table {表名} read;
		解锁：
			unlock tables;
	2.排它锁（X锁）
		加锁之后当前回话会独占资源，加锁的会话可读可写。其他回话不能读也不能写。
		加锁：
			lock table {表名} write;
		解锁：
			unlock tables;
	3.元数据锁
		简称MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。
		当开启事务并且执行对某一个表的查询操作之后，此时会对表加元数据锁，不允许对表结构进行修改操作。
	4.自增锁
		mysql支持自增主键，生成的主键不能重复，需要有自增锁保证生成的主键是唯一的。
四、行级锁
	注意事项：
		1.InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索的数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
		2.对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁。
		3.只有InnoDB引擎支持行锁。
	1、记录锁
		只锁定某一个表中的某一行记录。也有S锁和X锁两种类型。
		加锁的时机：根据主键等值查询，并且命中一条记录。
			update t set c = 'a' where id = 1;			--x锁
			delete from t where id = 1;					--x锁
			select * from t where id = 1 for update;	--x锁
			select * from t where id = 1 lock in share mode; --s锁
		注意事项：
			记录锁永远锁住的是索引，而非记录本身，所以说如果该表上没有任何索引，那么innodb会隐式的为每一行创建一个聚集索引，然后为每一行添加一个记录锁，这样就类似于表锁，但不是表锁
			所以我们加锁时尽量通过索引字段作为查询条件。命中尽量少的记录，防止锁住整个表。其他会话更新就会阻塞。降低性能
	2、间隙锁
		记录和记录之间的缝隙值，当加间隙锁后不允许缝隙值的插入。
		例如三条记录：
			id：1、5、10
		1和5之间的缝隙值就是2,3,4
		加锁的时机：通过主键更新(查询)数据没有命中任何记录时加间隙锁。
		间隙锁可用于防止幻读，保证索引间的不会被插入数据
	3、临键锁
		记录锁+间隙锁
		左开右闭的区间。边界包含取决于是否有等号
		根据主键范围更新加临键锁。默认的加锁方式，如果查询条件等值查询命中一条记录会退化成记录锁。
		如果没有命中任何记录会退化成间隙锁。
	
	4、意向锁（InnoDB表锁）
		定义：InnoDB也实现了表级锁，也就是意向锁，意向锁是mysql内部使用的，不需要用户干预。意向锁和行锁可以共存，意向锁的主要作用是为了【全表更新数据】时的性能提升。否则在全表更新数据时，需要先检索该范是否某些记录上面有行锁。
		当对表加表级锁，需要判断表中是否有行锁的存在，如果存在的话无法成功加锁。
		需要快速的知道表上是否有行锁的存在，引入了意向锁。
		在表中加行锁后，会在表上增加一个标志位，标志表中有行锁。
		注意：一个表中可以同时存在行共享锁和行排他锁，不能是同一行数据。所以一个表可以同时拥有意向共享锁和意向排他锁
	5、插入意向锁
		执行insert操作后，事务没有提交之前，需要锁定插入行的主键的值。防止其他事务使用此主键。（做insert操作时添加的对记录id的锁。）


五、死锁
	1、产生的原因
		两个事物互相持有对方请求的资源时就发生死锁。
	2、死锁之后的处理
		MySQL自动检测死锁，并且会自动回滚代价小的事务，解决死锁。
	3、减少死锁发生
		尽快释放资源，减少资源持有的时间。
		编码时按照约定好的顺序对表更新或者删除。
		
行锁加锁规则：
1）主键索引
	1. 等值查询
		（1）命中记录，加记录锁。
		（2）未命中记录，加间隙锁。锁上条记录的id和该条id之间
	2. 范围查询
		（1）没有命中任何一条记录时，加间隙锁。
		（2）命中1条或者多条，包含where条件的临键区间，加临键锁，是否包含边界取决于是否有等号
2）辅助索引
	1. 等值查询
		（1）命中记录，命中记录的辅助索引项+主键索引项加记录锁，辅助索引项两侧加间隙锁。
		（2）未命中记录，加间隙锁
	2. 范围查询
		（1）没有命中任何一条记录时，加间隙锁。
		（2）命中1条或者多条，包含where条件的临键区间加临键锁。命中记录的id索引项加记录锁。
注意事项：
	在rc隔离级别中，是不会加间隙锁的，因为rc级别是允许出现幻读的，
	在rr隔离级别中，会有间隙锁的存在，并且可以防止幻读，上面加锁规则中的间隙锁是指在rr隔离级别中
