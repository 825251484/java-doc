⚫软件设计名词
OOD - Object-Oriented Design(面向对象设计)
OOM - Object-Oriented Method(面向对象方法)
OOA - Object-Oriented Analysis(面向对象分析)
OOP - Object-Oriented Programming（面向对象编程）


⚫HashMap空值怎么处理？
空值hashcode返回0，


⚫HashMap为什么是线程不安全？
1、 1.7中扩容采用的是头插法，会导致在多线程环境下，扩容时会造成环形链或数据丢失。
2、 1.8在多线程put时，如果计算出来的哈希值相同会产生数据覆盖的问题


⚫ConcurrentModificationException产生的原因？
	hashMap类中全局变量modCount，HashIterator抽象类中全局变量expectedModCount，
	最开始他们是同步的，但是我们在某些操作的过程中会导致 他们不一致，例如put，remove。会修改hashmap中的modCount。但是HashIterator中expectedModCount却没有发生变化。
	当增强for循环再次执行的时候，调用的却是HashIterator中的方法nextNode方法，这个方法中获取的就是HashIterator中expectedModCount，
	最终发现了数据不一致。这就是本例ConcurrentModificationException 产生的根本原因。
链接：https://juejin.cn/post/6844903569095671816


⚫反射调用私有方法有什么问题？
在我们的开发过程中，通常只有实体类（Entity）中的成员变量使用 private 修饰，并且会提供访问这些变量的 get 和 set 方法。
原则上要求不准定义私有的方法，我们使用 method.invoke(Object obj,Object args[]); 强制调用对象调用私有方法违反了我们 Java 中面向对象的特性。


⚫Java 中iterator和iterable的关系是怎样的？有何意义？
public interface Iterable<T> {
  Iterator<T> iterator();
}
public interface Iterator<E> {
  boolean hasNext();
  E next();
  void remove();
}
原因是实现了Iterable的类可以在实现多个Iterator内部类，例如LinkedList中的ListItr和DescendingIterator两个内部类，就分别实现了双向遍历和逆序遍历。
通过返回不同的Iterator实现不同的遍历方式，这样更加灵活。如果把两个接口合并，就没法返回不同的Iterator实现类了。


⚫String相关知识
1、String实现哪些类：public final class String implements java.io.Serializable, Comparable<String>, CharSequence
2、String类中的方法  
	copyValueOf：传入char[]，返回一个字符串，内部调用new String
	valueOf：调用Long.toString(l); 或者Integer.toString(i);  等等
  
  
⚫Arrays.copy()和System.arraycopy()区别
Arrays.copy()：Arrays.copyOf()方法返回的数组是新的数组对象，底层new了一个新的数组，原数组对象仍是原数组对象，不变，该拷贝不会影响原来的数组，如果新数组的长度超过原数组的长度，则保留数组默认值.
System.arraycopy() ：System.arraycopy(original, 0, copy, 0,Math.min(original.length, newLength));
		 参数说明：
			original：源对象
			0：源数组中的起始位置
			copy：目标数组对象
			0：目标数据中的起始位置
			length：要拷贝的数组元素的数量，原数组和新数组取最小


⚫怎么通过方法表判断继承关系
从class文件中提取出来并存储在方法区
方法区中存储着类的信息：类名，直接父类的完整有效名包+类名（如果是接口或者object没有父类），类的修饰符
域的信息：成员变量的修饰符（static，final，volatile，public等），名称，类型
方法信息：方法名，参数类型个数顺序，方法修饰符，方法返回类型，
运行时常量池
Class class3=Class.forName("impressive.bean.Article");
Class class1=Article.class;
Article article1=(Article)class1.newInstance();


⚫什么是单例？
1.私有构造
2.使用私有静态成员变量初始化本身对象
3.对外提供静态公共方法获取本身对象
单例对象实现有两种：懒汉式（延迟加载, 用的时候在new），饿汉式


⚫单例破坏有哪些？
单例破坏：（破坏都是获取calss对象来处理，而单例是获取对象的）
1.1反射破坏：反射可以访问私有的构造方法，通过反射获取默认的私有构造器，并改变其构造器的访问域，从而实现调用构造器来创建对象
1.2防止反射破坏解决方案：在构造器中添加标志位，用来判断构造器是否被调用过，阻止外部调用构造器
2.1序列化破坏：序列化时底层是通过反射获取object对象的构造器来创建对象的（不是通过序列化对象的构造器创建对象），然后把object的引用指向被序列化的对象，导致反序列化之后对象不是之前的对象了
2.2防止序列化被破坏解决方案：在单例类中实现一个readResolve()方法，并在这个方法中返回我们要的单例对象。（反序列化时底层会检测单例类中是否有该方法。如果有返回该方法中的对象）


⚫防止单例破坏？
防止单例破坏
枚举类，防止反射和序列化的破坏
public enum SingletonDemo {
    INSTANCE;
    public static SingletonDemo getInstance() {
        return INSTANCE;
    }
}


⚫自动装箱拆箱

⚫多线程的原理

⚫进程间如何通信

⚫线程是如何创建和销毁
