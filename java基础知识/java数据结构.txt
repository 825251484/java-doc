⚫ArraryList和Linklist的区别
ArrayList ：动态数组。底层时Object[]数组
jdk8初始容量是0，当第一次添加数据时，会初始化一个长度为10的数组，当添加元素的个数大于数组长度，Arrary将以1.5倍扩容数组，并且无加载因子，就是简单的copyof一个1.5倍的数组，最大容量为Integer.MAX-1-8 ：-8是为了存储一些数组自己的元素。
并且线程不安全的，多线程同时修改数组时，会出现ArraryIndexOutOfBoundsException数组越界异常
Fail-Fast机制：快速失败机制，
	当多线程对集合进行结构上的修改时，或者迭代元素时直接调用自身方法改变集合结构而没有通知迭代器时，有可能触发快速失败机制，并抛出ConcurrentModificationException并发修改异常
	modCount != expectModCount就会抛出并发修改异常
jdk1.6默认，默认是new的时候，初始化一个长度10的数组，类似饿汉式，jdk1.6以后添加的时候才初始化一个长度为10的数组。类似于懒汉式


LinkedList：双向链表。
简介：接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括null），除了实现List接口外LinkedList类还为在列表的开头及结尾get、remove和insert元素提供了统一
的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。
概括：双向链表结构，有序，可存重复元素，含有带索引的方法？，可以做堆，栈，双端队列，查询慢，增删快
	特点：无默认值，无最大值限制，无扩容机制
	get(index)根据索引查找元素。底层采用二分法，判断索引在前半段还是后半段，前半段从头节点遍历，后半段从尾节点遍历
	
Vector：线程安全的动态数组。底层使用sync，可以设置扩容因子
CopyOnWriteArraryList:
ArraryList是线程不安全的集合类，在并发编程时可能报错：ConcurrentModificationException，而CopyOnWriteArrayList是juc中线程安全的集合类，底层利用读写分离的思想，
在写时把原来的数组复制一份，然后长度+1，把新添加的元素放在数组最后，同时添加过程中采用ReentrantLock保证多线程添加时，只有一个线程添加成功，添加成功后会放入原来的数据
，并且该数组由volatile修饰，保证可见性，修改了该数组，其他线程可以获取到最新的数组，在数组添加过程其他线程可以并发读取原来的数组，不需要加锁，所以CopyOnWrite容器也是一种读写分离的思想。



⚫hashmap和hashtable和concurrentHashmap区别？
Hashtable：继承Dictionary，implements Map<K,V>
	•底层数组+单向链表实现，无论key还是value都不能为null，synchronized线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable效率低，ConcurrentHashMap做了相关优化
	•初始size为11，达到0.75，当大小大于11*0.75，就会发送rehash，rehash就是扩容，扩容大小为：newsize = olesize*2+1，旧数组二倍+1，奇数是为了在计算数组下标时，减少哈希碰撞，计算出来的数组下标更加分散
	•计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length，括号内是为了得到一个正数然后和长度取余计算下标位置

Hashmap: 继承 AbstractMap，implements Map<K,V>
	•特点：无序，线程不安全，可以存储null键和null值
	•结构：	
		数组+单向链表 || 数组＋单向链表+红黑树
		数组：Node<K,V>[] tab
		链表：Node<K,V>
		红黑树：TreeNode<K,V>
		  
	•hashmap如何获取hashCode？
		源码：【return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);】扰动函数
		原理：获取hashCode，将hashCode转换成二进制，将二进制的hashCode右移16，目的是：把低位去掉，高位留下，剩下的高位和原始的hashCode，做【按位异或（^:相同为0，不同为1）】运算，
		将高位和原来hashCode异或运算，就是为了减少哈希碰撞的概率，这样元素就可以均匀的分布在数组中
	•hashMap如何计算数组下标？
		源码：【return h & (length-1);】
		原理：hashMap初始容量是16，
			16二级制：10000，32二进制：100000，64二进制：1000000
			15二进制：1111， 31二进制：11111   63二进制：111111
			&：0&1=0，0&0=0，1&1=1
			hashCode=5(二进制：101)，数组长度=8 [8-1=7](7二进制111)
			计算数组下标：101 & 111 = 101(5)
			也就是说。按位与计算中，任何和0与，结果都是0，这将导致很多计算结果会重复，为了保证计算结果不重复，hashMap使用数组长度再减一，就可以所有位都为1，更加减少了哈希碰撞碰撞
	•hashMap为何二倍扩容？
		1.原因一：
			hashMap初始容量是16，
			16二级制：10000，32二进制：100000，64二进制：1000000
			15二进制：1111， 31二进制：11111   63二进制：111111
			&：0&1=0，0&0=0，1&1=1
			也就是说。按位与计算中，任何和0与，结果都是0，这将导致很多计算结果会重复，为了保证计算结果不重复，hashMap使用数组长度（2的n次方）再减一(2n-1的二进制全是1)，就可以所有位都为1，更加减少了哈希碰撞冲突/碰撞，提高性能
		2.原因二：
			不需要移位：
				扩容前：hashCode=5(二进制：101)，数组长度=8 [8-1=7](7二进制111)
					计算数组下标：0101 & 111 = 101(5)
				扩容后：hashCode=5(二进制：101)，数组长度=16 [16-1=15](15二进制1111)
					计算数组下标：0101 & 1111 = 101(5)
				扩容前后，下标位置不变	
			
			需要移位：
				扩容前：hashCode=13(二进制：1101)，数组长度=8 [8-1=7]
					计算数组下标：1101 & 111 = 101(5)
				扩容后：hashCode=13(二进制：1101)，数组长度=16 [16-1=15]
					计算数组下标：1101 & 1111 = 1101(13)
				扩容前后，下标位置=原来下标+数组：13 = 5 + 8
			
			然而是否需要移位，需要看扩容后的数组长度-1的二进制的上方，也就是元素hashcode的最高位，如果和数组长度-1的最高位没有对齐，那就用0填补，如果这个位置是1需要移位，0不需要
			所以：HashMap的长度一定是2的次幂，还有另外一个原因，那就是在扩容迁移的时候，不需要再重新通过哈希定位新的位置了。扩容后，元素新的位置，要么在原脚标位，要么在原下标位置 + 旧数组 得到的位置，
				这样可以大大提高性能,效率更高
		
	•put流程
		1.首先判断node数组是否为空，如果是空创建一个默认容量为16的node数组
		2.按位与计算出当前key的下标位置（(n - 1) & hash），判断当前位置是否存在key，不存在则创建一个node节点放入数组，并将key-value放入节点。
		3.如果存在key，判断两个key的哈希值以及内容是否相等（内容用equals）。如果相等，则替换value，（第一个判断）
		4.如果不相等，则判断当前数组是否是treeNode（红黑树），如果是则交给红黑树追加此元素 （第二个判断）
		5.如果上面两个判断都不成立，key不相等，也不是红黑树，那么开始遍历链表中每一个key，如果相等就替换value，
		6.如果全不相等则再最后添加一个节点到链表中，然后判断该链表的长度是否大于8，如果小于8，添加元素结束，最后判断是否需要扩容。
		7.如果大于8，会将链表替换成红黑树，但是替换之前判断，数组是null或者数组的长度小于64，则重新散列，因为重新散列会拆分链表，使得链表的长度变短。提高性能
		8.如果长度大于64了。就只能将链表变为红黑树了，然后添加元素结束，最后判断是否需要扩容。
		注意：当链表的值小于6则会从红黑树转回链表

	•为什么加载因子是0.75？
		较大的加载因子会节省空间，但是数据也就越多，链表就会越长，这会导致查询变慢。
		较小的加载因子会提前扩容，浪费空间，
		是时间和空间成本上的一种折中选择

	•为什么链表长度达到8才转变红黑树？
		优秀的hash算法，会让所有桶的节点的分布频率会遵循泊松分布，选择8因为符合泊松分布，超过8的时候，概率已经非常小了，所以我们选择8这个数字，因此使用到红黑树的概率很小
	•什么是扩容？扩容做了什么？
		1.就是将数组的容量扩大，然后将原来的元素重新均分分布在新的数组中，
		2.由于每次扩容都是翻倍，与原来计算的 (n-1)&hash的结果相比，只是多了一个bit位。所以节点要么就在原来的位置，要么就被分配到"原位置+旧容量"这个位置。
		3.扩容必定伴随rehash操作（重新计算数组下标），遍历hash表中所有元素。这种操作比较耗时！在编程中，超大HashMap要尽量避免resize（扩容）， 避免的方法之一就是初始化固定HashMap大小！
	•使用建议：
		使用时建议设置初始容量，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会有可能发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的
		阿里容量设置公式：需要存储元素的个数/ 0.75F + 1.0F，例如：16/0.75 + 1 = 22
	•什么时哈希碰撞：
		两个对象调用的hashCode方法计算的哈希码值一致，导致计算的数组索引值相同。jdk8前使用链表解决哈希碰撞。jdk8及以后使用链表+红黑树解决哈希碰撞
	•注意：
		1.即便可以手动设置HashMap的初始化容量，但是最终还是会被重设为2的n次幂。通过无符号右位移运算符实现的。（n >>> 16）
		3.扩容必定伴随rehash操作，遍历hash表中所有元素。这种操作比较耗时！在编程中，超大HashMap要尽量避免resize， 避免的方法之一就是初始化固定HashMap大小！
	•其他：
		1.集合最大容量 : 10，7374，824【10亿】，2的30次幂。超过最大值就不再扩充了，就只好随你碰撞去吧
		2.扩容条件：1.元素的个数超过临界值。2.单个桶的链表长度达到8，数组长度小于64：因为如果数组太小。导致链表过长时，说明，hash冲突已经很严重了，这个时候扩容数组，比链表转换成红黑树，带来的效率更高
			毕竟树的查询效率O(logn)也比不上一个正常HashMap的O(1)的效率。
		3.jdk8在put时进行初始化一个16的数组
	

	
ConcurrentHashmap：键值都不能为空，线程安全，支持并发
	•是一个Segment数组，它通过继承ReentrantLock来进行加锁，通过每次锁住一个segment来保证每个segment内的操作的线程安全性从而实现全局线程安全
		1.8以后，取消了segment分段设计，采用与hashmap类似的结构，直接使用Node数组来保存数据，使用Node数组元素作为锁的粒度，从而实现了对每一行数据进行加锁,并发控制使用Synchronized和CAS来操作
jdk1.7 Segment数组 + hashEntry数组 + 链表：每一个segment数字节点对应一个hashEntry数组，而每个hashEntry节点对应一个链表，那么添加数组的时候会用ReentrantLock锁住整个segment数组节点。所以称这种方式为分段锁
jdk1.8 node数组+链表+红黑树：当链表长度大于8。数组长度大于64那么升级为红黑树。在结构上去掉了Segment，添加元素，容器是否为空，如果为空就通过volatile+cas来初始化，如果容器不为空。就要
根据数组下标判断，该位置使用有元素，如果该位置没有元素。那就通过cas添加节点。如果有元素就通过synlaichronized加锁，把当前数组对应的链表（桶）加锁，然后遍历链表，将元素追加在链表尾部，或者是key重复就替换。
 

synchronizedMap：
	•Collections 类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回，synchronizedMap()其实就是对Map的方法加层同步锁，
LinkHashMap：有序：存入顺序=取出顺序，内部before和after字段实现的排序功能
TreeMap：红黑树+数组，排序Comparator实现，不仅有序，还自带排序功能，默认升序。红黑树，


⚫HashMap为什么是线程不安全？
1、 1.7中扩容采用的是头插法，会导致在多线程环境下，扩容时会造成环形链或数据丢失。
2、 1.8在多线程put时，如果计算出来的哈希值相同会产生数据覆盖的问题


⚫ConcurrentModificationException产生的原因？
	hashMap类中全局变量modCount，HashIterator抽象类中全局变量expectedModCount，
	最开始他们是同步的，但是我们在某些操作的过程中会导致 他们不一致，例如put，remove。会修改hashmap中的modCount。但是HashIterator中expectedModCount却没有发生变化。
	当增强for循环再次执行的时候，调用的却是HashIterator中的方法nextNode方法，这个方法中获取的就是HashIterator中expectedModCount，
	最终发现了数据不一致。这就是本例ConcurrentModificationException 产生的根本原因。
链接：https://juejin.cn/post/6844903569095671816


⚫hashSet和treeSet区别
TreeSet底层使用treeMap的key来存储值，value固定存储final Object对象
hashSet使用hashMap


⚫红黑树和平衡二叉树的区别
链接：https://juejin.cn/post/6844903893315354632

⚫JAVA8,9,10,11,12新特性总结
java8函数式编程：https://juejin.cn/post/6844904184953700360
JAVA8特性：
  1、函数式接口：函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。：Runnable，Callable，Comparator
	Supplier<T> 生产者：无输入，生产一个T 类型的值；接口仅包含一个无参的方法:
	T get() 。用来获取一个泛型参数指定类型的对象数据
	Consumer<T> 消费者：输入一个T 类型的值，无输出；对给定参数执行消费操作
	Function<T,R> 函数：输入一个T 类型的值，返回一个R 类型的值；
	Predicate<T> 断言：输入一个T 类型的值，返回true/false
  2、lambda表达式：Lambda 它其实是匿名函数，通过约定好怎么传入参数，怎么返回参数，由编译器负责参数类型的猜测并执行结果
	new Thread(()->{System.out.println("快速新建并启动一个线程");}).start();
  3、Optional类：Optional 类的作用主要是为了解决空指针问题，通过对结果的包装，并使用方法来代替if 判断，为流式编程打下了良好的基础。
	        Optional<Object> o = Optional.ofNullable(null);
        	System.out.println(o.isPresent()); //打印：false 
  4、Stream 流式编程：Stream API 借助Lambda 表达式，提供串行和并行两种模式进行汇聚操作，并行模式parallelStream()能够充分利用多核处理器的优势，使用fork/join 来拆分任务和加速处理过程。并行有线程安全问题，同时stream提供了很多Stream API：concat,fiter,sorted,limit,foreach,reduce,count,min,findFirst,peek,distinct,toArrary,map操作（mapToLong等）
  5、方法引用(::双冒号操作符)
	Function<String, Integer> s = Integer::parseInt;
	Integer i = s.apply("10");
	Comparator<Integer> comparator = Integer::compare;
	int result = comparator.compare(100,10);
	规则：
	   返回类型：返回的类型是 Java 8 专门定义的函数式接口，这类接口用 @FunctionalInterface 注解。
	   参数：你的引用方法的参数个数、类型，返回值类型要和函数式接口中的方法声明一一对应才行。
	例如：以下两个方法都是一一对应的
	@FunctionalInterface
	public interface Function<T, R> {
	    R apply(T t);
	}
	public static int parseInt(String s) throws NumberFormatException {
	    return parseInt(s,10);
	}
  6、JDK8 新增了静态⽅法和默认⽅法
 默认方法子类可以选择实现，也可以不实现，为了提高的接口的使用性和扩展性，功能更类似于一个抽象类，
 静态方法子类不能直接调用，必须通过接口调用
  
JAVA9特性：
  1、目录变化：jvm启功时并非加载全部jar，减少启动时占用的内存
  2、接口私有化： JDK9 中新增了私有⽅法（JDK8 新增了静态⽅法和默认⽅法）
  3、集合加强：jdk9为所有集合（List/Set/Map）都增加了of 和copyOf 方法，用来创建不可变集合，即一旦创建就无法再执行添加、删除、替换、排序等，否则UnsupportedOperationException异常。
  4、Stream 方法增强：Stream 中增加了新的方法ofNullable、dropWhile、takeWhile 和iterate
  5、jshell 命令

JAVA10特性：
  1、局部变量类型推断JDK10 可以使⽤var 作为局部变量类型推断标识符，仅适⽤于局部变量

JAVA11特性：
  1、字符串加强： //去除首尾空格 strip();// 去除尾部空格 stripTrailing();// 去除首部空格 stripLeading()// 复制字符串 repeat(3)
  2、HttpClient API：，你可以在java.net 包中找到这个API它将替代仅适用于blocking 模式的HttpURLConnection，并提供对WebSocket 和HTTP/2 的支持。
  3、新一代垃圾回收器ZGC：

JAVA12特性：
  1、Switch：可以省去break
  2、Shenandoah GC新增了一个名为Shenandoah 的GC 算法，通过与正在运行的Java 线程同时进行evacuation（撤离） 工作来减少GC 暂停时间。使用Shenandoah 的暂停时间与堆大小无关，这意味着无论堆是200 MB 还是200 GB，都将具有相同的暂停时间
JAVA13特性：
  1、 默认生成类数据共享归档文件：在同一个虚拟机上启动多个JVM 时，如果每个虚拟机都单独装载自己需要的所有类，启动成本和内存占用成本很高。所以java 团队引入了类数据共享机制（CDS），将一些核心类在每个JVM 中共享，使启动时间减少，JVM 内存占用减少。
  2、可中断的G1 混合GC：当G1 垃圾回收器的回收超过暂停时间的目标，能中止垃圾回收过程，目的是使用户能够设置预期的JVM 停顿时间。G1 将GC 回收集分为了mandatory（紧急）和optional（可选）两部分，若处理完mandatory 后的时间小于设置的预期时间则会继续处理optional。
  3、ZGC 取消提交未使用的内存：ZGC 从JDK11 中被引入进来，在进行GC 的时候保证更短的停顿时间，10ms 以下， 在JDK13 中新增了归还未提交，未使用的内存给操作系统
  4、文字块：将文本块添加至java 语言，多行字符串不需要转义，提高代码的可读性。
HTML 示例：String html = "<html> <boby> <p> hello world </p> </boby> </html>";

⚫java内部类分类及特点
非静态内部类会持有外部类的引用。是因为内部类的构造器会传入外部类的对象引用。从而才能访问外部类的数据
静态内部类。不需要持有外类的引用。因为只可以通过类访问静态成员
匿名内部类：
public class Outer {
    String string = "";
    void outerTest(final char ch){
        final Integer integer = 1;
        Inner inner = new Inner() {
            void innerTest() {
                System.out.println(string);
                System.out.println(ch);
                System.out.println(integer);
            }
        };
    }
    public static void main(String[] args) {
        new Outer().outerTest(' ');
    }
    class Inner {
    }
}
为什么匿名内部类使用局部变量和方法参数就需要被final修饰：为不让内部类改变内容，使其参数值产生差异。索然加上final不让你们改。

