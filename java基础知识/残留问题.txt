⚫https保证安全性的过程


⚫进程间如何通信


⚫线程是如何创建和销毁


⚫怎么通过方法表判断继承关系
从class文件中提取出来并存储在方法区
方法区中存储着类的信息
	类名，直接父类的完整有效名包+类名（如果是接口或者object没有父类），类的修饰符
域的信息
	成员变量的修饰符（static，final，volatile，public等），名称，类型
方法信息
	方法名，参数类型个数顺序，方法修饰符，方法返回类型，
运行时常量池

Class class3=Class.forName("impressive.bean.Article");
Class class1=Article.class;
Article article1=(Article)class1.newInstance();


⚫ArraryList和Linklist的区别
ArrayList ：动态数组。
LinkedList：双向链表。
Vector：线程安全的动态数组。
	
⚫hashmap和hashtable和concurrentHashmap区别？
Hashtable：继承Dictionary，implements Map<K,V>
	•底层数组+单向链表实现，无论key还是value都不能为null，synchronized线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable效率低，ConcurrentHashMap做了相关优化
	•初始size为11，达到0.75，当大小大于11*0.75，就会发送rehash，rehash就是扩容，扩容大小为：newsize = olesize*2+1，旧数组二倍+1，奇数是为了在计算数组下标时，减少哈希碰撞，计算出来的数组下标更加分散
	•计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length，括号内是为了得到一个正数然后和长度取余计算下标位置

Hashmap: 继承 AbstractMap，implements Map<K,V>
	•特点：无序，线程不安全，可以存储null键和null值
	•结构：	
		数组+单向链表
		数组＋单向链表+红黑树（链表长度超过8，并且数组得长度大于64，才会出现红黑树结构）
		数组：Node<K,V>[] tab
		链表：Node<K,V>
		红黑树：TreeNode<K,V>
		  
	•hashmap如何获取hashCode？
		源码：【return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);】扰动函数
		原理：获取hashCode，将hashCode转换成二进制，将二进制的hashCode右移16，目的是：把低位去掉，高位留下，剩下的高位和原始的hashCode，做【按位异或（^:相同为0，不同为1）】运算，
		将高位和原来hashCode异或运算，就是为了减少哈希碰撞的概率，这样元素就可以均匀的分布在数组中
	•hashMap如何计算数组下标？
		源码：【return h & (length-1);】
		原理：hashMap初始容量是16，
			16二级制：10000，32二进制：100000，64二进制：1000000
			15二进制：1111， 31二进制：11111   63二进制：111111
			&：0&1=0，0&0=0，1&1=1
			hashCode=5(二进制：101)，数组长度=8 [8-1=7](7二进制111)
			计算数组下标：101 & 111 = 101(5)
			也就是说。按位与计算中，任何和0与，结果都是0，这将导致很多计算结果会重复，为了保证计算结果不重复，hashMap使用二倍扩容再减一，就可以所有位都为1，更加减少了哈希碰撞碰撞
	•hashMap为何二倍扩容？
		1.原因一：
			hashMap初始容量是16，
			16二级制：10000，32二进制：100000，64二进制：1000000
			15二进制：1111， 31二进制：11111   63二进制：111111
			&：0&1=0，0&0=0，1&1=1
			也就是说。按位与计算中，任何和0与，结果都是0，这将导致很多计算结果会重复，为了保证计算结果不重复，hashMap使用二倍扩容再减一(2n-1的二进制全是1)，就可以所有位都为1，更加减少了哈希碰撞冲突/碰撞，提高性能
		2.原因二：
			不需要移位：
				扩容前：hashCode=5(二进制：101)，数组长度=8 [8-1=7](7二进制111)
					计算数组下标：101 & 111 = 101(5)
				扩容后：hashCode=5(二进制：101)，数组长度=16 [16-1=15](15二进制1111)
					计算数组下标：101 & 1111 = 101(5)
				扩容前后，下标位置不变	
			
			需要移位：
				扩容前：hashCode=13(二进制：1101)，数组长度=8 [8-1=7]
					计算数组下标：1101 & 111 = 101(5)
				扩容后：hashCode=5(二进制：101)，数组长度=16 [16-1=15]
					计算数组下标：1101 & 1111 = 1101(13)
				扩容前后，下标位置=原来下标+数组：13 = 5 + 7
			
			然而是否需要移位，需要看hashCode值最高位是0还是1，如果是1需要移位，0不需要
			所以：HashMap的长度一定是2的次幂，还有另外一个原因，那就是在扩容迁移的时候，不需要再重新通过哈希定位新的位置了。扩容后，元素新的位置，要么在原脚标位，要么在原脚标位+扩容长度这么一个位置，
				这样可以大大提高性能,效率更高
		
	•put流程
		1.首先判断node数组是否为空，如果是空创建一个默认容量为16的node数组
		2.按位与计算出当前key的下标位置（(n - 1) & hash），判断当前位置是否存在key，不存在则创建一个node节点放入数组，并将key-value放入节点。
		3.如果存在key，判断两个key的哈希值以及内容是否相等（内容用equals）。如果相等，则替换value，（第一个判断）
		4.如果不相等，则判断当前数组是否是treeNode（红黑树），如果是则交给红黑树追加此元素 （第二个判断）
		5.如果上面两个判断都不成立，key不相等，也不是红黑树，那么开始遍历链表中每一个key，如果相等就替换value，
		6.如果全不相等则再最后添加一个节点到链表中，然后判断该链表的长度是否大于8，如果小于8，添加元素结束，最后判断是否需要扩容。
		7.如果大于8，会将链表替换成红黑树，但是替换之前判断，数组是null或者数组的长度小于64，则重新散列，因为重新散列会拆分链表，使得链表的长度变短。提高性能
		8.如果长度大于64了。就只能将链表变为红黑树了，然后添加元素结束，最后判断是否需要扩容。
		注意：当链表的值小于6则会从红黑树转回链表

	•为什么加载因子是0.75？
		较大的加载因子会节省空间，但是数据也就越多，链表就会越长，这会导致查询变慢。
		较小的加载因子会提前扩容，浪费空间，
		是时间和空间成本上的一种折中选择

	•为什么链表长度达到8才转变红黑树？
		优秀的hash算法，会让所有桶的节点的分布频率会遵循泊松分布，选择8因为符合泊松分布，超过8的时候，概率已经非常小了，所以我们选择8这个数字，因此使用到红黑树的概率很小
	•什么是扩容？扩容做了什么？
		1.就是将数组的容量扩大，然后将原来的元素重新均分分布在新的数组中，
		2.由于每次扩容都是翻倍，与原来计算的 (n-1)&hash的结果相比，只是多了一个bit位。所以节点要么就在原来的位置，要么就被分配到"原位置+旧容量"这个位置。
		3.扩容必定伴随rehash操作，遍历hash表中所有元素。这种操作比较耗时！在编程中，超大HashMap要尽量避免resize， 避免的方法之一就是初始化固定HashMap大小！
	•使用建议：
		使用时建议设置初始容量，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会有可能发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的
		阿里容量设置公式：需要存储元素的个数/ 0.75F + 1.0F，例如：16/0.75 + 1 = 22
	•什么时哈希碰撞：
		两个对象调用的hashCode方法计算的哈希码值一致，导致计算的数组索引值相同。jdk8前使用链表解决哈希碰撞。jdk8及以后使用链表+红黑树解决哈希碰撞
	•注意：
		1.即便可以手动设置HashMap的初始化容量，但是最终还是会被重设为2的n次幂。通过无符号有位移运算符实现的。（n >>> 16）
		3.扩容必定伴随rehash操作，遍历hash表中所有元素。这种操作比较耗时！在编程中，超大HashMap要尽量避免resize， 避免的方法之一就是初始化固定HashMap大小！
	•其他：
		1.集合最大容量 : 10，7374，824【10亿】，2的30次幂。超过最大值就不再扩充了，就只好随你碰撞去吧
		2.扩容条件：1.元素的个数超过临界值。2.单个桶的链表长度达到8，数组长度小于64
	
	•
	LinkHashMap：有序：存入顺序=取出顺序
	TreeMap：不仅有序，还自带排序功能，默认升序。红黑树
	
ConcurrentHashmap：键值都不能为空，线程安全，支持并发
	•是一个Segment数组，它通过继承ReentrantLock来进行加锁，通过每次锁住一个segment来保证每个segment内的操作的线程安全性从而实现全局线程安全
		1.8以后，取消了segment分段设计，采用与hashmap类似的结构，直接使用Node数组来保存数据，使用Node数组元素作为锁的粒度，从而实现了对每一行数据进行加锁,并发控制使用Synchronized和CAS来操作

synchronizedMap：
	•Collections 类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回，synchronizedMap()其实就是对Map的方法加层同步锁，


⚫session和cookie的区别  


⚫多节点，如何实现session共享



⚫spring有哪些容器
beanFactory applicationContext ListableBeanFactory



⚫java常用的集合


⚫自动装箱拆箱


⚫多线程的原理


⚫对象的内存布局


⚫对象的大小是8的倍数  对其填充



⚫jvm三色标记



⚫UML


⚫JAVA8,9,10,11,12新特性总结
java8函数式编程：https://juejin.cn/post/6844904184953700360
JAVA8特性：
1、函数式接口：
	Supplier<T> 生产者：无输入，生产一个T 类型的值；接口仅包含一个无参的方法:
	T get() 。用来获取一个泛型参数指定类型的对象数据
	Consumer<T> 消费者：输入一个T 类型的值，无输出；对给定参数执行消费操作
	Function<T,R> 函数：输入一个T 类型的值，返回一个R 类型的值；
	Predicate<T> 断言：输入一个T 类型的值，返回true/false
2.lambda表达式：Lambda 它其实是匿名函数，通过约定好怎么传入参数，怎么返回参数，由编译器负责参数类型的猜测并执行结果
	new Thread(()->{System.out.println("快速新建并启动一个线程");}).start();
3、Optional类：Optional 类的作用主要是为了解决空指针问题，通过对结果的包装，并使用方法来代替if 判断，为流式编程打下了良好的基础。
	        Optional<Object> o = Optional.ofNullable(null);
        	System.out.println(o.isPresent()); //打印：false 
4、Stream 流式编程：Stream API 借助Lambda 表达式，提供串行和并行两种模式进行汇聚操作，并行模式能够充分利用多核处理器的优势，使用fork/join 来拆分任务和加速处理过程。
	


⚫java内部类分类及特点
非静态内部类会持有外部类的引用。是因为内部类的构造器会传入外部类的对象引用。从而才能访问外部类的数据
静态内部类。不需要持有外类的引用。因为只可以通过类访问静态成员
匿名内部类：
public class Outer {
    String string = "";
    void outerTest(final char ch){
        final Integer integer = 1;
        Inner inner = new Inner() {
            void innerTest() {
                System.out.println(string);
                System.out.println(ch);
                System.out.println(integer);
            }
        };
    }
    public static void main(String[] args) {
        new Outer().outerTest(' ');
    }
    class Inner {
    }
}
为什么匿名内部类使用局部变量和方法参数就需要被final修饰：为不让内部类改变内容，使其参数值产生差异。索然加上final不让你们改。
