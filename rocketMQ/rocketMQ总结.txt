⚫生产者发送消息方法
同步：把消息发送到rocketmq服务器，阻塞并等待返回结果，拿到结果才能发送下一条
异步：把消息发送到rocketmq服务器，不用等待其返回结果，就可以发送下一条消息
单向：只管发送。消息可靠性不高，可能丢失消息，但是


⚫消费者接收消息方式
并发：MessageListenerConcurrently：内部通过线程池来创建多个线程，进行消费，批量消费
按顺序：MessageListenerOrderly：一次消费一个



⚫为什么使用消息队列进行应用解耦、异步处理、流量削峰、信息通信
异步解耦；异步处理请求，系统之间互不影响干扰。
削峰限流：比如系统中某个接口可以处理请求数是2k，如果访问任务远超承受的访问，那么可以使用mq来解决，比如把5000个消息先放入mq，然后每次消费1000个，剩下的放在Broker堆积慢慢消费就好
分布式事务一致性：可以做分布式事务，保证数据最终一致性
大数据分析：kafka


⚫如何保证消费消息的幂等性
	rocketmq并没有做消息去重。所以消息幂等需要业务方自己去控制。
	1.乐观锁方式：
		插入：根据业务插入一条唯一的记录（唯一主键字段），插入成功代表第一次消费，插入失败不做业务处理，注意：需要让插入记录和业务处理放在同一事务中
		更新：数据更新时条件带上状态，例如：where statu = 1（数据库排他锁），更新成功代表第一次消费，更新失败，代表重复消费，不做处理
	2.分布式锁：
		可以通过业务上唯一标识来控制消息幂等，比如订单号，水流号等，第一次消费后，把唯一标识存在redis或者关系型数据库中，第二次先查询是否存在该记录，不存在则消费消息，存在则不做处理，
		先查询在更新/插入，由于存在并发消费，该流程不是原子操作，所以采用分布式锁保证线程安全。


⚫如何保证生产者发送消息的可靠性



⚫如何保证消息的顺序性
rocketmq顺序消息


⚫怎么解决消息积压和消息过期的问题
问题根源：由于消费者者的问题，导致生产消息的速度大于消费者的消费速度，就会产生消息积压，或者生产上消费者出现故障，导致无法消费，这个时候也会导致消息积压
1.首先加快修复消费者的问题，看一下消息是否有必要处理。如果是一些日志消息，堆积的消息可能不用处理，等消费者修复后，重新上线，直接跳过指定时间的offset。从指定offset开始消费
2.首先加快修复消费者的问题，如果消息是有效消息，且必须处理的业务消息，那么这个时候需要：写一个临时的消费者，不进行耗时业务处理只进行消息的分发。根据消息堆积的数量，临时创建10倍，20倍的队列。
通过临时消费者，将消息均匀的分发到所有队列中。然后征用10的机器，来部署consumer，每一批consumer消费一个临时队列，
这种做法相当于queue和consumer临时扩大10倍，以正常速度的十倍来消费消息，等消费万消息之后，恢复到原来的部署架构。根据堆积的消息多少适当调整扩容的queue和consumer


⚫你所熟知的消息队列有哪些。简述优缺点
activeMQ：java语言，万级吞吐量，延时毫秒级，会有消息丢失的情况，
rabbitMQ：erlang语言，万级吞吐，延时微秒级，延迟最低，性能好，但是吞吐量不及rocketmq，不支持顺序消息，中小公司用的多，语言限制，定制化开发比较难，国外上使用较多
rocketMQ：java语言，十万级吞吐，毫秒级，功能丰富，支持多种消息类型（顺序消息，事务消息），吞吐量大，在同等机器下，可以支持大量topic，达到几百/几千时吞吐量会有较小的下降，（kafka达到几百吞吐量大幅下降），阿里系社区活跃，java开发可支持定制化开发，国内使用较多
kafka：scala语言（斯卡拉），十万级吞吐，毫秒级，大数据实时计算，日志采集，如果需要大量的topic需要增加更多的机器资源


⚫消息队列的一般存储方式有哪些
文件系统，
分布式KV存储：levelDB，redis
关系型数据库DB
存储效率：文件系统 > KV存储 > DB


⚫如何自己设计消息队列
map+linkList




⚫robbitmq
exchange：做消息分发，分发到不同的队列中
queue：多个队列可以并行消费。队列之间互不干扰
channel：多个通道共用一个连接socket。为了并行处理
虚拟机：多租户的概念。就是一个企业中，共用一个rabbitmq机器，但是多个部门之间不想互相干扰。所以这个虚拟机起到一个隔离的作用，独立的工作空间，为了隔离数据，
		多租户存在逻辑上的，和物理上的。逻辑上的可能存在资源抢用，因为物理上是共用一个机器。所以多租户时要选用物理上的多租户，每隔租户用自己独立的物理结构
		
		
⚫robbitmq保证消息可靠性投递
RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式。confirm 确认模式  return 退回模式
消息从生产者(producer)发送消息到交换机(exchange)，不论是否成功，都会执行一个确认回调方法confirmCallback 。
消息从交换机(exchange)到消息队列( queue )投递失败则会执行一个返回回调方法 returnCallback