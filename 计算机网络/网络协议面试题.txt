⚫什么是http？
http是一种基于应用层的一种超文本传输协议。用于服务之间的数据传输，他是建立在tcp/ip协议基础之上的应用层协议，并且是无状态的协议，不会记录每次访问时的信息


⚫http内部结构？
请求行：请求方式+url+http版本
请求头：
	host：端口号或者域名
	connectiong：连接属性：keep-Alive
	Accept-Charset：浏览器接收的编码格式
	Accept-Encoding：压缩格式
	Content-Type：对请求体中的数据，解码格式
请求头和请求体之间有一个空行作为分割线
请求体：数据报文

响应行：协议版本+状态码+状态描述OK
状态码分类：
200-299的状态码表示成功，
300-399的状态码指资源重定向，
400-499的状态码指客户端请求出错（服务器无法处理请求），400请求报文中出现语法错误  403服务器收到请求但是拒绝提供服务，404找不到资源, 401未经授权
500-599的状态码指服务端出错 （服务器处理请求出错）  500服务器内部逻辑错误，503服务器停机维护无法处理请求

响应头和响应体同上


⚫OSI七层协议和五层协议？
7层是指OSI七层协议模型，主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。
五层协议是在七层协议的基础上把：应用层（Application）、表示层（Presentation）、会话层（Session）合并，统称为应用层
四层协议是为了综合tcp/ip，因为业界主要使用tcp/ip协议，所以产生了非官方协议的四层协议模型。把:数据链路层（Data Link）、物理层（Physical）合并为：网络接口层


⚫URL和URI的区别？
URL统一资源定位符，提供找到该资源的路径或者地址，是URI的一种，类似于家庭住址
URI统一资源标识符：用于标识唯一的资源，包括URL  类似于身份证


⚫TCP和UDP的区别？
两者都是传输层的协议，
区别在于tcp是面向连接的，可靠的全双工字节流传输协议，而udp是无连接，不可靠面向报文的传输协议，
因为UDP无需建立连接，并且不能保证数据是否一定到达，所以dup传输效率更高，适合用在对网络通讯质量要求不高，要求高效率，低准确性的场景，例如视频音频通信、DNS等
TCP需要三次握手四次挥手，并且是可靠的传输协议。所以可以保证数据的准确性，但是效率略低，，所以一搬用在万维网http，邮件发送等场景


⚫TCP三次握手的原理
三次握手：
通过三次握手建立链接。那么先说一下在握手的过程中传递的几个参数
1.SYN:是用来建立连接，表示发送端要建立连接。
2.ACK:是一个应答参数。1表示应答有效，0无效。
3.seq:表示报文段中第一个数据字节在数据流中的序号，主要解决报文乱序的问题 
4.ack:表示发送端，期望收到的下一个确认序号，只有当ACK=1时，此参数才有效，为了解决不丢包的问题   ack=发送方的seq+发送方的len
发送过程：
	1.客户端发送SYN=1,seq=x数据包(x为初始序列号)，给服务端，此时客户端状态变成SYN_SENT状态
	2.服务端收到客户端发来的SYN=1,表示建立连接的请求，然后把向客户端发送SYN=1,ACK=1,seq=y,ack=x+1数据包，服务端状变成SYN_RCVD
	3.客户端收到服务端的请求后，验证数据ack是否是期望的值=x+1，然后给服务端发送ACK=1,seq=x+1,ack=y+1。状态：确认建立连接状态
	4.服务端收到请求验证ack是否等于自己的seq+1也就是等于y+1，验证通过，状态：确认建立连接状态
seq=x+1的原因：
	因为建立连接时是不需要传输数据的，但要消耗掉一个序号，也就是说过告诉对方，下次我序号开始的位置，就是为了解决数据乱序的问题

为什么要三次握手？
	为了防止过期的报文，再次发送给服务器端。如果只有两次握手，一条报文由于网络延迟，在连接关闭以后，发送到了服务端。那么这时服务端认为客户端要建立连接，便打开连接。
	然后一直等待客户端的响应，但是客户端并没有发送连接，这就导致连接的资源被白白浪费掉了，所以要三次握手
tcp有四大特性，可靠传输、流量控制、拥塞控制、连接管理
	
	
⚫四次挥手原理
FIN:表示请求断开连接，
	1.客户端请求关闭连接发送FIN=1,seq=x给服务端，状态变成：wait1，这时候客户端还可以接受来之服务端的请求
	2.服务端收到FIN报文，给客户端发送ACK=1,ack=x+1，状态变成close_wait状态，表示自己收到了客户端的请求，并等待自己关闭连接，
	3 客户端收到服务端的ACK+ack报文，这时客户端还可以接收服务端的消息，客户端状态变成wait2
	4.服务端没有数据发送给客户端了。这时向客户端发送关闭连接请求FIN=1,seq=y，表示请求关闭连接，此时变成last_ack状态
	5.客户端收到服务端的FIN报文。表示服务端请求关闭连接，然后向服务端发送ACK=1,ack=y+1，变成time_wait状态，然后等待2msl后变成close状态
	6.服务端收到来自客户端ack报文，说明客户端已经关闭连接了。自己也变成了close状态。
为什么要等待2SML?
	为了保证服务端能够收到ACK报文，如果失败在2SML内还可以重新发送ACK报文，保证可靠的关闭
为什么要四次挥手？
	由于TCP是全双工模式。所以为了保证自己不能接收消息，同时也不能发送消息，才能关闭当前链接，所以需要四次握手：既告诉对方自己不会发送消息，同时也要让对方告诉自己对方不会在发消息了。这样才能保证完全关闭连接



⚫Restful和RPC区别
文章：https://blog.igevin.info/posts/restful-architecture-in-general/#roa_soa_rest_rpc
RPC被称为远程过程调用，服务之间的调用就像调用本地方法一样便捷。RPC主要用在分布式架构中服务之间的调用，分为同步调用，异步调用，底层还是使用http协议
	同步调用：调用一个服务需要等待其返回才能继续执行程序，主要技术有dubbo，springcloud中插件  feigen   （Dubbo 是阿里集团开源的一个极为出名的 RPC 框架）
	异步调用：调用一个服务，不需要等待其返回值，就可以继续执行。主要框架有：rocketMQ、kafka、ActiveMQ等等
restful是一种软件架构风格，满足REST约束条件和原则的架构，就被称为是RESTful架构，rest就是通过http协议，按照不同的请求方式：(GET、PUT（幂等）、DELETE、POST，PATCH)，来请求资源的，并且通过url来对网络资源进行标识

两者区别：RPC接口更简单高效，因为只传输与接口相关的参数，而http拥有更丰富的功能（请求头，权限验证，状态码等），利于扩展，所以http性能传输更低效



⚫HttpURLConnection、HttpClient、OKHttp区别
　HttpURLConnection是JDK自带的HTTP客户端技术，并不支持连接池，如果要实现连接池的机制，还需要自己来管理连接对象。对于网络请求这种底层相对复杂的操作，如果有可用的其他方案，也没有必要自己去管理连接对象。
　Apache提供的HttpClient框架相比传统JDK自带的HttpURLConnection，它封装了访问http的请求头，参数，内容体，响应等等；它不仅使客户端发送HTTP请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性；另外高并发大量的请求网络的时候，还是用“HTTP连接池”提升吞吐量。
　OKHttp是一个处理网络请求的开源项目,是安卓端最火热的轻量级框架,由移动支付Square公司贡献用于替代HttpUrlConnection和Apache HttpClient。OKHttp拥有共享Socket,减少对服务器的请求次数，通过连接池,减少了请求延迟等技术特点。


⚫rpc调用层，tcp/ip如何找到目标ip



⚫输入一个网址。请求过程
文章：https://juejin.cn/post/6844903665631756295
1.域名解析找到ip端口号
	DNS域名解析过程：www.taobao.com
		1.查询浏览器缓存是否有域名对应的ip地址，如果没有
		2.查询该机器的操作系统缓存中，也就是hosts文件中是否有配置域名
		3.查询本地DNS服务器，比如过你通过学校服务器接入的网络，那么就查询学校DNS服务器
		4.查询根域名服务器（根域名服务器是最高层次的域名服务器，知道所有顶级域名服务器的域名和ip），他告诉本地域名服务器，去.com的顶级域名服务器去查询
		5.查询顶级域名武器(.com顶级域名服务器)，他又告诉本地域名服务器，去权威域名服务器查询，这个过程就是迭代查询
		6.查询权威域名服务器（.taobao.com域名服务器），返回ip
		7.然后把ip返回给本地服务器也就是学校的DNS服务器，在返回给主机的浏览器，缓存解析结果
		备注：递归查询就是主机查询不到时，本地服务器就要以你的名义去请求其他域名服务器，

2.建立tcp连接
	三次握手
3.发送http请求
	浏览器与服务器建立TCP连接以后，然后就可以开始发起HTTP请求了，客户端按照指定格式开始向服务器发送HTTP请求，服务端接收请求后，解析HTTP请求，处理完业务逻辑，返回一个HTTP响应给客户端
4.解析解析，渲染
	浏览器拿到http请求返回的html页面进行渲染返回给客户
	
在浏览器获取html文件时涉及到的缓存问题
	1.当浏览器第一次向服务器发送请求时，服务器会将缓存的规则参数放入请求头中返回，有几个重要参数：
		Cache-Control：Cache-Control代表缓存规则，主要用于控制网页缓存规则（Expires缓存过期时间，HTTP/1.1，Expires已经被Cache-Control替代）
		Last-Modified：服务器上的资源的最后修改时间
		Etag：当前资源文件的唯一的编号
	2.当我第二次发起请求时，如果cache-control：no-cache，那么直接进入协商缓存的流程，如果cache-control：max-age=xxx（缓存在xxx后失效），那么就会比较时间，看当前缓存是否过期，如果过期那么走协商缓存，
	（是否走强制缓存要看Cache-Control配置，强制缓存（本地缓存）分为：浏览器缓存，硬盘缓存（内存缓存(from memory cache) 和硬盘缓存(from disk cache):）
	3.如果走协商缓存，那么客户端再次发起该请求时，并携带某一个参数：
		If-Modified-Since = Last-Modified
		If-None-Match = Etag
		服务器收到请求后，先判断Etag值是否相等，相等则返回304表示资源无更新，不相等返回资源文件，状态200
		或者判断Last-Modified是否一致，如果一致代表资源无更新，不一致返回新的Last-Modified和资源文件，状态200
	4.Cache-Control参数取值
		cache-control: max-age=xxxx，public
		客户端和代理服务器都可以缓存该资源；
		客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求
		cache-control: max-age=xxxx，private
		只让客户端可以缓存该资源；代理服务器不缓存
		客户端在xxx秒内直接读取缓存,statu code:200
		cache-control: max-age=xxxx，immutable
		客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求
		cache-control: no-cache
		跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。
		cache-control: no-store
		不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。
	
⚫http中post和get区别
参考文章：https://juejin.cn/post/6992933721703710750
GET和POST方法只是HTTP协议为了不同分工而规定的两种请求方式，两者底层都是tcp链接，本质上是无差别的，两者之所以不同是因为，http协议规则和浏览器的限制导致两者在使用中有着一些差别
两者作用：
	get用来获取资源
	post一搬用来提交资源
使用不同：
	1.请求参数不一样。get放在url中传递参数。post在boby中传递参数
	2.get请求参数长度有限制，这个取决于浏览器的限制。http并没有限制
	3.GET 只接受 ASCII 字符，而 POST 没有限制。
	4.编码不一样：get请求只能进行 URL 编码（application/x-www-form-urlencoded），POST 支持多种编码方式（application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多种编码。）
	5.GET 请求会被浏览器主动cache，而 POST 不会，除非手动设置
请求过程不同：
	get请求会产生一个数据包，把header和data一并发送出去，服务器响应200，
	POST会产生两个数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200
	
	
⚫https保证安全性的过程
