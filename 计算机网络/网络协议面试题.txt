⚫什么是http？
http是一种基于应用层的一种超文本传输协议。用于服务之间的数据传输，他是建立在tcp/ip协议基础之上的应用层协议，并且是无状态的协议，不会记录每次访问时的信息


⚫http内部结构？
请求行：请求方式+url+http版本
请求头：
	host：端口号或者域名
	connectiong：连接属性：keep-Alive
	Accept-Charset：浏览器接收的编码格式
	Accept-Encoding：压缩格式
	Content-Type：对请求体中的数据，解码格式
请求头和请求体之间有一个空行作为分割线
请求体：数据报文

响应行：协议版本+状态码+状态描述OK
状态码分类：
200-299的状态码表示成功，
300-399的状态码指资源重定向，
400-499的状态码指客户端请求出错（服务器无法处理请求），400请求报文中出现语法错误  403服务器收到请求但是拒绝提供服务，404找不到资源  401未经授权
500-599的状态码指服务端出错 （服务器处理请求出错）  500服务器内部逻辑错误，503服务器停机维护无法处理请求
响应头和响应体同上


	
⚫http中post和get区别
文章：https://juejin.cn/post/6992933721703710750
GET和POST方法只是HTTP协议为了不同分工而规定的两种请求方式，两者底层都是tcp链接，本质上是无差别的，两者之所以不同是因为，http协议规则和浏览器的限制导致两者在使用中有着一些差别
两者作用：
	get用来获取资源
	post一搬用来提交资源
使用不同：
	1.请求参数不一样。get放在url中传递参数。post在boby中传递参数
	2.get请求参数长度有限制，这个取决于浏览器的限制。http并没有限制
	3.GET 只接受 ASCII 字符，而 POST 没有限制。
	4.编码不一样：get请求只能进行 URL 编码（application/x-www-form-urlencoded），POST 支持多种编码方式（application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多种编码。）
	5.GET 请求会被浏览器主动cache，而 POST 不会，除非手动设置
请求过程不同：
	get请求会产生一个数据包，把header和data一并发送出去，服务器响应200，
	POST会产生两个数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200
	
	
⚫https保证安全性的过程
http协议属于明文传输协议，交互过程以及数据传输都没有进行加密，通信双方也没有进行任何认证，通信过程非常容易遭遇劫持、监听、篡改
甚至造成个人隐私泄露（比如银行卡卡号和密码泄露）等严重的安全问题

HTTPS超文本传输安全协议，HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。
SSL2.0和SSL3.0已经被IEFT组织废弃，仅仅保留 TLS 协议开启。
HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。

非对称加密：它需要两个密钥，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密（或者反过来私钥机密，公钥解密），公钥加密只能密钥解密，公钥也解不了。简单来说，非对称加密就是两个密码，公钥交给对方，私钥自己藏好
对称加密：加密解密都用同一个密钥称为对称加密

那么要想使传输变的安全，可以把公钥放在数字证书中，只要证书可信，公钥就可信，所以CA办法证书的机构，就是用来发放和管理数字证书的权威机构，只要是ca颁发的证书，那就是可信的
数字证书的作用就是是对方互相认证，然后建立一个安全通道，在这个通道基础上，采用对称加密的方式传输数据，

参考连接:https://zhuanlan.zhihu.com/p/110216210
https://baijiahao.baidu.com/s?id=1741928361322073046&wfr=spider&for=pc
https://baijiahao.baidu.com/s?id=1652147355202637603&wfr=spider&for=pc



⚫OSI七层协议和五层协议？
7层是指OSI七层协议模型，主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。
五层协议是在七层协议的基础上把：应用层（Application）、表示层（Presentation）、会话层（Session）合并，统称为应用层
四层协议是为了综合tcp/ip，因为业界主要使用tcp/ip协议，所以产生了非官方协议的四层协议模型。把:数据链路层（Data Link）、物理层（Physical）合并为：网络接口层


⚫URL和URI的区别？
URL统一资源定位符，提供找到该资源的路径或者地址，是URI的一种，类似于家庭住址
URI统一资源标识符：用于标识唯一的资源，包括URL  类似于身份证


⚫TCP和UDP的区别？
两者都是传输层的协议，
区别在于tcp是面向连接的，可靠的全双工字节流传输协议，而udp是无连接，不可靠面向报文的传输协议，
因为UDP无需建立连接，支持一对多，多对多交互通信，并且不能保证数据是否一定到达，所以dup传输效率更高，适合用在对网络通讯质量要求不高，要求高效率，低准确性的场景，例如视频音频通信、DNS,广播等
TCP需要三次握手四次挥手，并且是可靠的传输协议。所以可以保证数据的准确性，但是效率略低，，所以一搬用在万维网http，FTP文件传输等场景


⚫TCP三次握手的原理
三次握手：
通过三次握手建立链接。那么先说一下在握手的过程中传递的几个参数
1.SYN:是用来建立连接，表示发送端要建立连接。
2.ACK:是一个应答参数。1表示应答有效，0无效。
3.seq:表示报文段中第一个数据字节在数据流中的序号，主要解决报文乱序的问题 
4.ack:表示发送端，期望收到的下一个确认序号，只有当ACK=1时，此参数才有效，为了解决不丢包的问题   ack=发送方的seq+发送方的len
发送过程：
	1.客户端发送SYN=1,seq=x数据包(x为初始序列号)，给服务端，此时客户端状态变成SYN_SENT状态
	2.服务端收到客户端发来的SYN=1,表示建立连接的请求，然后向客户端发送SYN=1,ACK=1,seq=y,ack=x+1数据包，服务端状变成SYN_RCVD
	3.客户端收到服务端的请求后，验证数据ack是否是期望的值=x+1，然后给服务端发送ACK=1,seq=x+1,ack=y+1。状态：确认建立连接状态
	4.服务端收到请求验证ack是否等于自己的seq+1也就是等于y+1，验证通过，状态：确认建立连接状态
seq=x+1的原因：
	因为ACK的传输是不需要传输数据的，也不会消耗一个序号，也就是说过告诉对方，下次我序号开始的位置还是X+1，
	也就是自己的X加上1，这个1是我之前发送SYN时消耗的，就是为了解决数据乱序的问题
	注意：SYN/FIN的传输，虽然没有data，但是会让下一次传输的packet seq增加一，但是，ACK的传输，不会让下一次的传输packet seq加一，所以第三传输的seq还是x+1

为什么要三次握手？
	主要三点：1.阻止历史重复连接 2.同步双方的初始序列号 3.避免资源浪费
	为了防止过期的报文，再次发送给服务器端。如果只有两次握手，一条报文由于网络延迟，在连接关闭以后，发送到了服务端。那么这时服务端认为客户端要建立连接，便打开连接。
	然后一直等待客户端的响应，但是客户端并没有发送连接，这就导致连接的资源被白白浪费掉了，所以要三次握手，同时三次也是为了互相确认序列号
tcp有四大特性，可靠传输、流量控制、拥塞控制、连接管理
参考文章：https://www.cnblogs.com/muyi23333/articles/13841268.html
	
	
	
⚫四次挥手原理
FIN:表示请求断开连接，
	1.客户端请求关闭连接发送FIN=1,seq=x给服务端，状态变成：wait1，这时候客户端还可以接受来之服务端的请求
	2.服务端收到FIN报文，给客户端发送ACK=1,ack=x+1，状态变成close_wait状态，表示自己收到了客户端的请求，并等待自己关闭连接，
	3 客户端收到服务端的ACK+ack报文，这时客户端还可以接收服务端的消息，客户端状态变成wait2
	4.服务端没有数据发送给客户端了。这时向客户端发送关闭连接请求FIN=1,seq=y，表示请求关闭连接，此时变成last_ack状态
	5.客户端收到服务端的FIN报文。表示服务端请求关闭连接，然后向服务端发送ACK=1,ack=y+1，变成time_wait状态（也就是等待2MSL），然后等待2msl后变成close状态
	6.服务端收到来自客户端ack报文，说明客户端已经关闭连接了。自己也变成了close状态。
为什么要等待2SML?
	MSL是报文的最大生存时间
	在2sml内如果服务端没有接收到客户端的ACK报文，那么服务端会重新发送FIN报文，
	2msl就是从服务端发送FIN，到服务端接受ACK一来一回，就是2sml，
	而对于客户端而言，如果2sml内没有收到服务端重新发送的FIN报文，就证明服务端已经收到ACK报文并已经关闭。
	这样做就是为了保证服务端能够收到ACK报文，保证连接可以正常关闭
为什么要四次挥手？
	由于TCP是全双工模式。所以为了保证自己不能接收消息，同时也不能发送消息，才能关闭当前链接，所以需要四次握手：既告诉对方自己不会发送消息，同时也要让对方告诉自己对方不会在发消息了。这样才能保证完全关闭连接
如果已经建立连接，但客户端出现故障怎么办？
	TCP中有一个保活机制，这个机制的原理是：在这个时间段，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，如果连续几个探测报文都没有得到响应，则认为当前的TCP连接已经死亡
time_wait过长或者过短的影响？
	1.过短会产生数据错乱等严重的问题 2.过长占满了所有端口资源，则会导致无法创建新连接
参考文章：https://mp.weixin.qq.com/s/ihDCVCI4jm24XDZ9bCTfqQ



⚫Restful和RPC区别
文章：https://blog.igevin.info/posts/restful-architecture-in-general/#roa_soa_rest_rpc
RPC被称为远程过程调用，服务之间的调用就像调用本地方法一样便捷。RPC主要用在分布式架构中服务之间的调用，分为同步调用，异步调用，底层还是使用http协议
	同步调用：调用一个服务需要等待其返回才能继续执行程序，主要技术有dubbo，springcloud中插件  feigen   （Dubbo 是阿里集团开源的一个极为出名的 RPC 框架）
	异步调用：调用一个服务，不需要等待其返回值，就可以继续执行。主要框架有：rocketMQ、kafka、ActiveMQ等等
restful是一种软件架构风格，满足REST约束条件和原则的架构，就被称为是RESTful架构，rest就是通过http协议，按照不同的请求方式：(GET、PUT（幂等）、DELETE、POST，PATCH)，来请求资源的，并且通过url来对网络资源进行标识

两者区别：RPC接口更简单高效，因为只传输与接口相关的参数，而http拥有更丰富的功能（请求头，权限验证，状态码等），利于扩展，所以http性能传输更低效



⚫HttpURLConnection、HttpClient、OKHttp区别
1、HttpURLConnection是JDK自带的HTTP客户端技术，并不支持连接池，如果要实现连接池的机制，还需要自己来管理连接对象。对于网络请求这种底层相对复杂的操作，如果有可用的其他方案，也没有必要自己去管理连接对象。功能基础，需手动处理输入输出流。
2、Apache提供的HttpClient框架相比传统JDK自带的HttpURLConnection，它封装了访问http的请求头，参数，内容体，响应等等；它不仅使客户端发送HTTP请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性；另外高并发大量的请求网络的时候，还是用“HTTP连接池”提升吞吐量。功能强大，但较重量级。
3、HttpClient：Java 11 引入了新的 HttpClient，支持 HTTP/2 和异步请求
4、OKHttp是一个处理网络请求的开源项目，是安卓端最火热的轻量级框架,由移动支付Square公司贡献用于替代HttpUrlConnection和Apache HttpClient。OKHttp拥有共享Socket,减少对服务器的请求次数，通过连接池,减少了请求延迟等技术特点。支持HTTP/2，默认高效，Android开发首选
复杂需求（如重试、连接池）：选择 Apache HttpClient 或 OkHttp。

推荐
Android/高并发服务：OkHttp（性能最优，功能齐全）。
传统 Java 项目：Apache HttpClient（功能全面，稳定）。
JDK 11+ 新项目：HttpClient（未来趋势，但功能较基础）。


⚫Socket和WebSocket区别
1、Socket
	定义：Socket 是操作系统提供的 底层网络通信接口，基于 TCP/IP 或 UDP 协议。
	作用：用于两台机器之间的 原始数据通信（字节流或数据报）。
	特点：
		不限定协议（可以是 HTTP、FTP、自定义协议等）。
		需要手动处理连接、数据分包、粘包等问题。
2、WebSocket
	定义：WebSocket 是 基于 HTTP 升级的应用层协议（RFC 6455），提供全双工通信。
	作用：用于浏览器和服务器之间的实时双向通信（如聊天室、股票行情）。
	特点：
	建立在 TCP 之上，依赖HTTP握手（Upgrade: websocket）。
	自动处理数据帧（Frame），无需手动分包。

3、关系对比
特性	Socket			WebSocket
层级	传输层（TCP/UDP）		应用层（基于 HTTP 升级）
协议	无固定协议		固定协议（ws:// 或 wss://）
通信方式	单向或双向（需自己实现）	全双工（天生支持双向通信）
复杂度	高（需处理底层细节）	低（自动管理连接、帧格式）
典型用途	自定义协议、网络工具	网页实时通信（如聊天、游戏）

总结：WebSocket是基于Socket实现的高级协议，专为Web实时通信设计，而 Socket 是更通用的底层工具。



⚫输入一个网址。请求过程
参考文章：https://juejin.cn/post/6844903665631756295
1.域名解析找到ip端口号
	DNS域名解析过程：www.taobao.com
		1.查询浏览器缓存是否有域名对应的ip地址，如果没有
		2.查询该机器的操作系统缓存中，也就是hosts文件中是否有配置域名
		3.查询本地DNS服务器，比如过你通过学校服务器接入的网络，那么就查询学校DNS服务器
		4.查询根域名服务器（根域名服务器是最高层次的域名服务器，知道所有顶级域名服务器的域名和ip），他告诉本地域名服务器，去.com的顶级域名服务器去查询
		5.查询顶级域名武器(.com顶级域名服务器)，他又告诉本地域名服务器，去权威域名服务器查询，这个过程就是迭代查询
		6.查询权威域名服务器（.taobao.com域名服务器），返回ip
		7.然后把ip返回给本地服务器也就是学校的DNS服务器，在返回给主机的浏览器，缓存解析结果
		备注：递归查询就是主机查询不到时，本地服务器就要以你的名义去请求其他域名服务器，

2.建立tcp连接
	三次握手
3.发送http请求
	浏览器与服务器建立TCP连接以后，然后就可以开始发起HTTP请求了，客户端按照指定格式开始向服务器发送HTTP请求，服务端接收请求后，解析HTTP请求，处理完业务逻辑，返回一个HTTP响应给客户端
4.解析解析，渲染
	浏览器拿到http请求返回的html页面进行渲染返回给客户
	http1.1中Connection: keep-alive是长连接，所以一次url请求后，tcp不会断开/不会四次回收，除非设置Connection: close，请求完就关闭


⚫在浏览器获取html文件时涉及到的缓存问题
	1.当浏览器第一次向服务器发送请求时，服务器会将缓存的规则参数放入响应头中返回，有几个重要参数：
		Cache-Control：Cache-Control代表缓存规则，主要用于控制网页缓存规则（Expires缓存过期时间，HTTP/1.1，Expires已经被Cache-Control替代）
			如果cache-control：no-store：完全禁用缓存，每次请求都从服务器获取最新资源。
			如果cache-control：no-cache，那么就不会走强制缓存了，直接进入协商缓存的流程，
			如果cache-control：max-age=3600（缓存在一个小时后失效），那么就会比较时间，看当前缓存是否过期，如果过期那么走协商缓存，
		Last-Modified：服务器上的资源的最后修改时间
		Etag：当前资源文件的唯一的编号
	2.第二次发起请求时
		浏览器发现 max-age=3600 未过期，直接读取本地缓存，不会向服务器发送请求。
		
	（是否走强制缓存要看Cache-Control配置，强制缓存（本地缓存）分为：浏览器缓存，硬盘缓存（内存缓存(from memory cache) 和硬盘缓存(from disk cache):）
	3.第三次请求：
		# 浏览器发送条件请求（携带之前服务器返回的ETag）
		GET /index.html HTTP/1.1
		If-None-Match: "abc123"  # 浏览器问：“资源还是abc123吗？”  -- 
		
		# 服务器检查后响应
		HTTP/1.1 304 Not Modified  # 服务器说：“没变，继续用缓存吧” --服务器收到请求后，先判断Etag值是否相等，相等则返回304表示资源无更新，不相等返回资源文件，状态200 或者判断Last-Modified是否一致，如果一致代表资源无更新，不一致返回新的Last-Modified和资源文件，状态200
		Cache-Control: max-age=3600 # 重新下发缓存规则
	参数说明
	If-Modified-Since = Last-Modified
	If-None-Match = Etag
