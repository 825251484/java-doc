⚫5种IO模型
1.同步阻塞IO：BIO
	用户线程通过系统调用read发起IO读操作，由用户态转到内核态。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。整个过程是被阻塞的，发起io请求后，不能做任何事情，对CPU利用率不高
2.同步非阻塞：Non-Blocking IO
	用户发起IO操作，去读取数据，或者写数据时，如果数据还没有准备好（准备数据。以及数据拷贝工作），那么会立刻返回，并不会一直等待，然后线程采用轮询的方式（死循环）去调用recv（调用操作系统来数据文件拷贝），来获取数据，
		缺点：如果没有数据导致空循环，会消耗CPU资源，如果在高并发场景，成千上万的请求过来，只有几个请求完成数据读取，那么大多数循环将是无效的调用，
3.IO多路复用：同步阻塞IO：
	多路是指多个io请求，复用是指同一个线程，用一个线程来监视多个IO请求，在liunx系统中叫fd（文件描述符，在window中叫文件句柄），java提供select、poll方法对多路复用的支持（设计数据拷贝），如果有一个请求或者多个请求，数据准备完毕，
	就会返回给应用程序进行读写操作，会返回所有的文件句柄，遍历fd，找到其中准备完毕的fd进行操作，如果没有请求，那么将会一直阻塞，虽然select、poll是阻塞的，但是实际上是底层是非阻塞的？？
		优点：相比较于NIO，只需要用一个线程就可以管理多个IO，大大提高了并发性能。并且只一次系统调用即可返回多个准备就绪的fd
		缺点：同样存在一个问题就是每次都循环所有的fd。底层每次就要把所有fd从内核空间拷贝到用户空间，降低了效率
	底层原理：Java NIO中的Channel，Buffer，Selector，SelectionKey就是基于这种Reactor模型设计的，
		Reactor事件驱动模型，是操作系统底层实现的一种设计吗，java中Selector对其有实现
		单线程Reactor，
			通过把请求封装到事件中，Reactor付责监控事件。
			1.服务器端的Reactor线程对象会启动事件循环，并使用Selector来实现IO的多路复用
			2.注册Acceptor事件处理器到Reactor中，Acceptor事件处理器所关注的事件是ACCEPT事件，这样Reactor会监听客户端向服务器端发起的连接请求事件
			3.客户端向服务器端发起连接请求，Reactor监听到了该ACCEPT事件的发生并将该ACCEPT事件派发给相应的Acceptor处理器来进行处理。Acceptor处理器通过accept()方法得到与这个客户端对应的连接(SocketChannel)，
			  然后将该连接所关注的READ/WRITE事件以及对应的READ/WRITE事件处理器注册到Reactor中，这样一来Reactor就会监听该连接的READ/WRITE事件了。
			4.当Reactor监听到有读或者写事件发生时，将相关的事件派发给对应的处理器进行处理
			5.每当处理完所有就绪的感兴趣的I/O事件后，Reactor线程会再次执行select()阻塞等待新的事件就绪并将其分派给对应处理器进行处理
			
			IO操作和业务操作在一个线程，
		多线程Reactor：
			业务处理用线程池来实现。
		多Reactor：
			Reactor线程池中的每一Reactor线程都会有自己的Selector、线程和分发的事件循环逻辑。
			mainReactor可以只有一个，但subReactor一般会有多个。mainReactor线程主要负责接收客户端的连接请求，然后将接收到的SocketChannel传递给subReactor，由subReactor来完成和客户端的通信。
4.IO 模型之信号驱动IO(SIGIO)
	信号驱动IO与BIO和NIO最大的区别就在于，在IO执行的数据准备阶段，不会阻塞用户进程。
	 如下图所示：当用户进程需要等待数据的时候，会向内核发送一个信号，告诉内核我要什么数据，然后用户进程就继续做别的事情去了，而当内核中的数据准备好之后，内核立马发给用户进程一个信号，说”数据准备好了，快来查收“，
	 用户进程收到信号之后，立马调用recvfrom，去查收数据
 
5.IO 模型之异步IO(AIO)：
	异步IO真正实现了IO全流程的非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，
	然后发送信号告诉用户进程IO操作执行完毕（与SIGIO相比，一个是发送信号告诉用户进程数据准备完毕，一个是IO执行完毕）

文章：https://blog.csdn.net/qq_36414013/article/details/100620871
	  https://www.cnblogs.com/shujiying/p/12386505.html
	  https://cloud.tencent.com/developer/article/1648650
	  https://zhuanlan.zhihu.com/p/115912936
	  https://blog.csdn.net/weililansehudiefei/article/details/70885515 Java IO多路复用技术详解（图）
	
⚫Reactor比传统IO快的原因：
从模型上来讲，如果仅仅还是只使用一个线程池来处理客户端连接的网络读写，以及业务计算，那么Reactor模型与传统IO模型在效率上并没有什么提升。
但是Reactor模型是以事件进行驱动的，其能够将接收客户端连接，+ 网络读和网络写，以及业务计算进行拆分，从而极大的提升处理效率； 
Reactor模型是异步非阻塞模型，工作线程在没有网络事件时可以处理其他的任务，而不用像传统IO那样必须阻塞等待。

⚫reactor底层原理
https://wjrsbu.smartapps.cn/zhihu/article?id=93612337&isShared=1&_swebfr=1&_swebFromHost=heytapbrowser
将IO请求注册成事件，把该事件注册到reactor中，通过事件分离器的select来获取准备就绪的事件，如果准备就绪了，那么事件分离器把返回的事件交给reactor，reactor再把该事件handle交给事件处理器。处理对应的请求。


⚫epoll  零拷贝，mmap()函数，技术，https://zhuanlan.zhihu.com/p/442343024  这种系数需要底层操作系统支持  在linux中使用该数据。 window下使用select和poll


多线程同步Natty
单线程异步非阻塞redis
多线程异步memcached
多进程异步nginx



