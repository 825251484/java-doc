一、秒杀系统
核心架构
技术栈：Redis（库存预热/扣减） + RocketMQ（异步削峰） + Sentinel（限流熔断）
流程：
  1）预热阶段：将商品库存提前加载到Redis集群，采用分片存储（如商品ID哈希分片到不同Redis节点）。
  2）秒杀阶段：
    用户请求先经过Sentinel限流（如QPS控制在10万级）。
    Redis执行Lua脚本原子扣减库存（DECR + 校验库存≥0）。
    成功扣减的请求发送到RocketMQ，由消费者服务异步生成订单。
  3）最终一致性：MQ消费者处理失败时，通过定时任务补偿库存或订单状态。
2. 解决Redis单点问题
Redis Cluster：数据分片存储，避免单节点压力。
多级缓存：本地缓存（Caffeine）+ Redis集群，本地缓存兜底减少Redis访问。
持久化备份：AOF+RDB持久化，主从同步（哨兵自动切换）。

3. 数据一致性方案
扣减原子性：通过Redis Lua脚本保证“校验库存→扣减”的原子性。
事务消息：RocketMQ的事务消息确保订单创建与库存扣减最终一致（半消息+本地事务表）。
对账补偿：定时任务核对Redis库存与DB订单，修复不一致状态。


▪️秒杀系统中的支付流程如何触发？
在阿里Seckill的异步扣减架构中，支付流程的触发时机和实现方式如下：
支付流程的关键步骤
  1、秒杀资格获取阶段：
    用户请求秒杀，Redis通过Lua脚本原子扣减库存。
    扣减成功后，生成一个临时秒杀令牌（Token）返回给用户，并发送MQ消息到RocketMQ。
    此时未生成真实订单，仅表示用户获得了购买资格（避免订单系统压力）。
  2、订单创建阶段：
    MQ消费者异步消费消息，调用订单服务生成待支付订单（状态为“未支付”）。
    订单服务将订单数据写入数据库，同时设置支付超时时间（如15分钟）。
  
  3、支付拉起阶段：
    前端拿到秒杀令牌后，轮询或通过WebSocket接收订单创建完成的通知。
    订单创建成功后，前端跳转到支付页面（支付宝/微信支付等）。
    支付成功后，订单状态变更为“已支付”；支付超时则自动取消订单，库存回滚。

为什么异步生成订单？
  削峰：将订单创建的IO压力从秒杀瞬间转移到MQ异步消费。
  防超卖：先扣Redis库存，再生成订单，确保不会超卖。
  用户体验：用户快速得知是否抢到资格，支付流程可稍后完成。

支付一致性问题
  支付超时：通过定时任务扫描“未支付”订单，超时后关闭订单并回滚库存（Redis INCR）。
  支付失败：依赖支付平台的回调通知，若未收到回调，需对账系统修复状态。

▪️商品库存分片设计如何解决单点压力？
方案一：库存分片（适用于可分割库存）
分片逻辑：
  将100件库存拆分为10个分片（如stock_1~stock_10，每个分片10件）。
  用户请求通过商品ID + 哈希算法（如user_id % 10）路由到不同分片。
优势：将单商品压力分散到多个Redis节点，提升并发能力。
问题：分片不均：某些分片可能提前扣完，导致部分用户无法抢购（即使总库存未耗尽）。
解决方案：
  动态分片再平衡：
  监控各分片库存，当某分片耗尽时，从其他分片“借调”库存（需原子操作）。
  例如：通过Redis的INCRBY将分片A的库存转移到分片B。

秒杀场景流程
前端调用库存服务，先通过lua原子扣减库存，在lua中校验库存是否超卖，如果不超卖，通过rockeetmq发送事务消息给订单服务，
订单服务创建订单，并且将订单放入延迟队列15分钟。同时通过websocket通知前端，前端收到通知调用支付服务，拉起支付。
如果支付成功异步通知订单服务更新转交给太，否则订单15分钟未支付，取消之前查询支付服务是否已经支付，
如果未支付，把订单取消，然后通知库存服务，进行库存回滚，库存服务收到之后先校验订单状态，在校验支付状态，判断是否满足回滚要求。
如果满足通过lua表达式+1回滚库存，但是这个时候可能存在并大扣减的请求，那么把扣减和回滚放在一个lua脚本中执行，保证其原子性。
不会出现库存被覆盖的问题。


二、抢红包
一、红包系统的核心流程
1. 发红包阶段
  1）金额预分配
  1️⃣线段分割算法：
    在内存中预先将总金额随机拆分为N份（N为红包个数）。
    例如：100元拆成5个红包，在内存中生成序列[20, 30, 15, 25, 10]。
  2️⃣随机性保证：
    采用二倍均值法：每次随机金额在[0.01, 剩余均值×2]之间，避免极端分布。
    预分配结果存入Redis List（如RPUSH红包ID 20 30 15...）。

 2）元数据存储
  红包基本信息（总金额、个数、发送者）写入MySQL分库分表（按红包ID哈希分片）。
  Redis存储预分配金额列表和已领取用户ID集合（防重）。

2. 抢红包阶段
1）资格校验
  检查用户是否已领取（SISMEMBER 红包ID:users 用户ID）。
  检查红包是否剩余（LLEN 红包ID > 0）。
2）原子分配
  通过Redis的RPOP从预分配列表中弹出金额，并记录用户ID（SADD 红包ID:users 用户ID）。
  原子性保证：Lua脚本合并RPOP和SADD操作。
    # 预分配红包金额（二倍均值法生成）
    amounts = [2.50, 1.80, 3.20, 1.90, 0.60]  # 示例：10元拆分为5个红包
    
    # 存入Redis List（Key格式：red_packet:{红包ID}）
    redis.lpush("red_packet:123456", *amounts)  # 结果为List: [0.60, 1.90, 3.20, 1.80, 2.50]
3）异步入账
  抢红包结果通过RocketMQ发送到账户服务，异步更新用户余额（最终一致性）。

3. 退款与对账
  超时未领完：定时任务扫描未领完的红包，剩余金额原路退回。
  对账系统：定期核对Redis、MySQL、账户系统的数据一致性。


参考：https://chat.deepseek.com/a/chat/s/7eef8e89-6be2-4c57-80cb-cc1f9ecdfcb8

三、设计一个12306系统



四、写一个测压的逻辑，并发度10，持续5分钟


五、设计一个会议室系统
 * mysql一主多从
 * 会议室表
 * 用户表
 * 预定记录表
 *
 * 核心工作流程：
 * 1、预定：选择时间，会议室
 * 2、取消/查询：查到预定记录进行取消
 *
 * 抢会议室流程
 * 1、会议室展示页面：会议室状态。只有空闲的才能抢
 * 2、用户限制校验：查询预定表，校验当天是否有预定过，校验选择时间是否争取
 * 3、冲突检查：
      方案一：先加读锁：会议室id_开始时间搓，然后通过redis lua校验时间冲突，用redis set存储每一次的时间，不存在冲突就执行逻辑，保存预定记录，更新会议室状态，发消息发邮件通知，释放锁，
      方案二：通过select * from table where start> and end< for update 通过时间条件添加行锁互斥锁。如果有冲突，那么就会监测到这个锁，返回会议室被占用

六、有n个运营人员，每个人需要查询100w个手机号，发送消息。
方案1：定时任务，集群模式，500台机器，每台机器分发一个0-499随机数，然后手机号对500取模，模几等于下发这个随机数就处理，这样的话，一次执行定时任务，500台机器，一起执行100w数据。每台机器2000条
方案2：消息队列。每次查询1w条发送到多分区的队列中，然后消费者开启线程池。

