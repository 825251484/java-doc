1、外卖境内和境外有啥差异，和相同点


2、职业规划，如何做好一个管理者
  1）、技术和业务提升：技术和业务上需要提升技术的广度和深度，并且从更层角度看待问题和架构，业务上对业务理解程度要更透彻，并且能把控业务的发展走向，并转成对应的技术目标
  2）、管理上的提升：人员的管理和需求的管理：
    1、人的管理：向上汇报：结论先行原则，例如：进度多少，风险是什么，然后再讲原因。向下指导：人员上做好定期沟通，根据个人意向为期制定合理目标，以便让成员打成目标有更好的成就感，
    2、需求管理：需求池维护整理，优先级排序，合理分配高优先级需求


3、外卖管控服务的设计考虑哪些？怎么搭建的？
外卖骑手端，骑手管控服务业务流程餐

4、你做着的这些难点在哪？是怎么解决的？
业务的复杂性带来代码的复杂性，如果无脑的流水开发，对日后的增量迭代带来是难维护，扩展性差，上线风险大。
所以在项目初期，需要理解业务，根据业务搭建服务，管控服务就是对骑手的履约过程的管控与治理。按照配送过程分析，骑手配送过程中肯定会有违规，不履约，或者遇到一些问题。
所以针对不履约过程就要对骑手处罚，那怎么处罚，那根据什么处罚呢，那就看骑手有哪些违规，不同违规匹配不同处罚方案，那违规怎么生成，就是需要对骑手履约过程判责，判责就需要根据具体场景具体分析，是送达超时，还是延误到店等。


5、讲讲项目
判责类型：
完成单判责：送达超时判责、送达位置异常判责、提前点送达判责、延误到店判责、到点位置异常判责、延误取餐判责、取餐位置异常判责
取消单：取消单盼责，非取消单判责。
封控单判责：
判责之后会产生，判责结果：责任方，违规类型，是否免责等。

经过判责之后，会生成违规类型。先有判责结果再有违规结果，如果盼着结果被免责，就不生成违规，如果盼着结果被申诉成功，违规会被作废


6、diffset原理和diff注解的原理，diffset是否承接正常流量？
1）diffset原理：aop方式，拦截需要diff的方法，在切面中，通过配置内容，找到目标的类和方法，以及appkey，模拟客户端通过okhttp，异步线程池发送一个http请求。然后执行原方法（diffset方法），
原方法结束之后，再创建一个异步线程，在线程中通过CompletableFuture获取默认set中结果，进行对比，对比之后把结果放入es
2）diff注解：请求过来，通过切面方式实现，在切面中，执行原方法，把目标方法封装到Supplier中，然后开启异步线程，把目标方法的查询结果 和 封装的Supplier传入异步线程，异步线程执行：Object target = targetSupplier.get();// 在异步线程中执行目标方法
然后将传入的结果和异步的结果，做比较


7、如何实现支付系统

8、线程阻塞会导致cpu飙升么？锁的等待和join阻塞有什么区别
  当一个线程进入阻塞状态（如 WAITING、TIMED_WAITING、BLOCKED）时：
  线程被挂起，不再被操作系统调度执行。
  CPU不会分配时间片给阻塞的线程，因此不会占用CPU计算资源。
  线程进入等待队列，直到某个条件（如I/O完成、锁释放、notify() 调用等）触发唤醒。

9、微服务的背景下，多机房部署，如何降低延迟，有哪些负载均衡策略？
主流方案：通常集成加权轮询（结合实时指标（CPU、延迟、错误率）加权之后，进行轮训）、最少连接和地域感知


10、线程阻塞是否会消耗cpu？，
线程阻塞本身不会消耗CPU，因为阻塞的线程不会被调度执行。
CPU飙升通常是由于阻塞后的唤醒、锁竞争（自旋🔒）或线程调度问题，而不是阻塞本身。
合理使用锁、线程池和异步I/O（如NIO）可以减少不必要的阻塞，提高系统性能。


11、redis使用zset做排行榜，插入和查找的时间复杂度是多少？
当排行榜的元素小雨128使用，使用压缩表，压缩表，查询和插入都是On，如果大于123使用跳跃表+哈希表实现，redis底层维护两个数据结构，单通过key查询某一个人排行使用的是哈希表o1，当范围查询使用的是跳跃表。ologn

12、java中哪种数据结构类似跳跃表？有封装好的对象么？
ConcurrentSkipListMap 和 ConcurrentSkipListSet：跳跃表
TreeMap 和 TreeSet：红黑树

对比总结
特性	          ConcurrentSkipListMap	  TreeMap
底层结构	      跳跃表	                  红黑树
查询复杂度	    O(log n)	              O(log n)
插入复杂度	    O(log n)	              O(log n)
范围查询复杂度	O(log n + m)	          O(log n + m)
线程安全	      是	                    否
内存占用	      较高（多层指针）	          较低
实现难度	      较复杂	                  相对简单
总结：两种结构都能高效支持范围查询，选择依据主要是：
1、需要线程安全 → ConcurrentSkipListMap
2、单线程追求更高性能 → TreeMap
3、需要更严格的有序遍历 → TreeMap（红黑树的有序遍历更稳定）

