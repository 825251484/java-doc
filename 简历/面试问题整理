1、外卖境内和境外有啥差异，和相同点


2、职业规划，如何提升自己做好一个管理者
往技术管理者路线发展，类似阿里的高p职位p8p9，短期还是要强化自己的技术能力，从原理到架构，从细节到全局，同时培养自己团队管理能力，
长期主导核心中大型项目的搭建或者重构，目标是成为技术驱动业务增长的领导者。
  1）、技术和业务提升：技术和业务上需要提升技术的广度和深度，并且从更层角度看待问题和架构，业务上对业务理解程度要更透彻，并且能把控业务的发展走向，并转成对应的技术目标
  2）、管理上的提升：人员的管理和需求的管理：
    1、人的管理：向上汇报：结论先行原则，例如：进度多少，风险是什么，然后再讲原因。向下指导：人员上做好定期沟通，根据个人意向为期制定合理目标，以便让成员打成目标有更好的成就感，
    2、需求管理：需求池维护整理，优先级排序，合理分配高优先级需求

2.1、在现在的公司中你有哪些成长？
1）技术上：
  1、技术深度：使用新的框架有看底层的源码，对原理有一定的了解，
  2、实战能力：主导解决了线上mysql死锁，消息积压，redis集群抖动等题，并沉淀出相应的文档
  3、架构能力：对高并大高流量系统架构设计和技术选型的能力也有一定的提升
2）管理上：1、负责日常小团队的管理。包括：日常指导、目标指定和考核、需求分配

2.2、对实习生应届生如何管理？
1）需求分配：
2）日常工作指导：业务指导、技术指导、线上问题解决指导
3）制定目标并考核：
  熟悉期：环境搭建，代码规范（代码cr识别），负责模块画出简单流程图、
  上手期：实现简单的功能并输出简单的设计方案，测试阶段代码bug小于5个，单侧覆盖率80%，会使用开发工具
  提升期：独立完成一个简单需求的从评审到开发到上线的全流程，独立解决线上问题并能提出相应的解决方案，代码bug小于3，

2.3、项目中你是如何管理的？
一、技术决策
  1、技术选型：mysql和es和redis选型，缓存选型，mq，锁等等，实验平台选型，api文档选型
  2、架构治理：工程结构治理，代码治理（高内聚低耦合），领域建模，服务可用性，可靠性治理，可扩展，可维护性，可观测
二、研发管理
  1、需求管理：维护需求池，优先实现价值比较高的需求，技术需求要占比20%（一些产品需求方案选择会造成一些技术债务）
  2、流程管理：把控设计方案，代码质量，缺陷略，严控上线时间避免延期，严格规范上线流程，任何线上变更都需审批。任何上线做到可灰度+可回滚
  3、沟通协作：主导跨团队协作（与PMO、QA、SRE团队的接口对齐），对其方案，和重要时间节点。
三、团队建设
  1、能力培养：每个月安排一个人做技术分享
  2、指定团队目标和个人目标：大目标拆解为可快速验证的小里程碑




3、外卖管控服务的设计考虑哪些？怎么搭建的？
外卖骑手端，骑手管控服务业务流程餐

4、你做着的这些难点在哪？是怎么解决的？
业务的复杂性带来代码的复杂性，如果无脑的流水开发，对日后的增量迭代带来是难维护，扩展性差，上线风险大。
所以在项目初期，需要理解业务，根据业务搭建服务，管控服务就是对骑手的履约过程的管控与治理。按照配送过程分析，骑手配送过程中肯定会有违规，不履约，或者遇到一些问题。
所以针对不履约过程就要对骑手处罚，那怎么处罚，那根据什么处罚呢，那就看骑手有哪些违规，不同违规匹配不同处罚方案，那违规怎么生成，就是需要对骑手履约过程判责，判责就需要根据具体场景具体分析，是送达超时，还是延误到店等。


5、讲讲项目
一、判责域
  1）判责类型：
    完成单判责：送达超时判责、送达位置异常判责、提前点送达判责、延误到店判责、到点位置异常判责、延误取餐判责、取餐位置异常判责
    取消单：取消单盼责，非取消单判责。
    封控单判责：风控异常单判责，风控虚假单判责
  2）判责结果：基于判责逻辑最终产出的结果，判责结果中明确责任方、违规类型，以及是否被免责等信息
  3）判责幂等：租户code_判责场景code_任务单id
经过判责之后，会生成违规类型。先有判责结果再有违规结果，如果盼着结果被免责，就不生成违规，如果盼着结果被申诉成功，违规会被作废

违规类型：经判责后产出的判责结果类型、例如送餐位置异常，异常单、开工抽检不通过等
违规结果：用于处罚、申诉的核心数据依据、一定先有判责结果，再有违规结果、如果判责结果被自动免责，则不再生成违规结果，如果违规结果被申诉通过，则违规结果会被作废，不再针对该违规进行处罚。

二、处罚域
  1、处罚模式：单次处罚、违规聚次处罚、任务单聚次处罚
  2、处罚方案：针对处罚模式和违规类型进行处罚的执行策略的具体描述
  3、处罚结果：根据违规类型匹配对应的处罚方案，进一步根据违规次数匹配到对应的处罚规则，产生对应的处罚结果，比如处罚非本人跑单3次，限制开工3天

三、外卖项目难点和挑战点
背景：
架构：两个项目：一个骑手app管控服务：判责处罚，抽检报备申诉的核心逻辑，一个运营管理平台服务：管控数据配置查询等。mysql存储，redis分布式，kafka消息
难点一：外卖这个项目流量和并发度都很低，难点主要体现在业务的复杂性，比如多种判责场景，取餐位置异常判责，延迟送达判责等等，每个场景判断内容都不同，获取的元数据也不同，
比如抽检分上线抽检，完单抽检，完单抽检需要一定的抽检策略，比如异常报备：大订单，交通拥堵等，调用的接口也都不一样。
解决方案一：所以解决这些复杂的场景。需要在不同的场景使用不同的设计模式。判责和报备场景使用策略模式、完单抽检使用责任链+模板模式+策略、aop锁代理模式等。
难点二：如何支持不同国家个性化处理+快速开国+语言文案展示
解决方案二：用动态配置代替代码中写死的国家地区处理，比如配置是个map结构key是国家，value是配置内容，可以线上动态修改，也可支持新增国家场景。
用语言配置平台支持文展展示，需求设计阶段产品提供展示的多国文案，设计阶段我们定义key，上线前配置到语言平台上，我们在在代码中通过key和国家获取文案返回给前端
难点三：随机业务的迭代，代码可读性变差，大量重复代码，比如灰度策略，sql写两套读从和读主，比如接口重试，控制层代码混乱
解决方案三：抽出公共主键，灰度策略，定义各种类型的模板方案，例如控制层模板，service层模板，adpter层模板，存储层模板，



6、diffset原理和diff注解的原理，diffset是否承接正常流量？
1）diffset原理：aop方式，拦截需要diff的方法，在切面中，通过配置内容，找到目标的类和方法，以及appkey，模拟客户端通过okhttp，异步线程池发送一个http请求。然后执行原方法（diffset方法），
原方法结束之后，再创建一个异步线程，在线程中通过CompletableFuture获取默认set中结果，进行对比，对比之后把结果放入es
2）diff注解：请求过来，通过切面方式实现，在切面中，执行原方法，把目标方法封装到Supplier中，然后开启异步线程，把目标方法的查询结果 和 封装的Supplier传入异步线程，异步线程执行：Object target = targetSupplier.get();// 在异步线程中执行目标方法
然后将传入的结果和异步的结果，做比较


7、如何实现支付系统，如何实现一个抢红包系统，设计一个lru算法

8、线程阻塞会导致cpu飙升么？锁的等待和join阻塞有什么区别
  当一个线程进入阻塞状态（如 WAITING、TIMED_WAITING、BLOCKED）时：
  线程被挂起，不再被操作系统调度执行。
  CPU不会分配时间片给阻塞的线程，因此不会占用CPU计算资源。
  线程进入等待队列，直到某个条件（如I/O完成、锁释放、notify() 调用等）触发唤醒。

9、微服务的背景下，多机房部署，如何降低延迟，有哪些负载均衡策略？
主流方案：通常集成加权轮询（结合实时指标（CPU、延迟、错误率）加权之后，进行轮训）、最少连接和地域感知


10、线程阻塞是否会消耗cpu？，
线程阻塞本身不会消耗CPU，因为阻塞的线程不会被调度执行。
CPU飙升通常是由于阻塞后的唤醒、锁竞争（自旋🔒）或线程调度问题，而不是阻塞本身。
合理使用锁、线程池和异步I/O（如NIO）可以减少不必要的阻塞，提高系统性能。


11、redis使用zset做排行榜，插入和查找的时间复杂度是多少？
当排行榜的元素小雨128使用，使用压缩表，压缩表，查询和插入都是On，如果大于123使用跳跃表+哈希表实现，redis底层维护两个数据结构，单通过key查询某一个人排行使用的是哈希表o1，当范围查询使用的是跳跃表。ologn

12、java中哪种数据结构类似跳跃表？有封装好的对象么？
ConcurrentSkipListMap 和 ConcurrentSkipListSet：跳跃表
TreeMap 和 TreeSet：红黑树

对比总结
特性	        ConcurrentSkipListMap	  TreeMap
底层结构	      跳跃表	                  红黑树
查询复杂度	    O(log n)	              O(log n)
插入复杂度	    O(log n)	              O(log n)
范围查询复杂度	O(log n + m)	          O(log n + m)
线程安全	      是	                    否
内存占用	      较高（多层指针）	          较低
实现难度	      较复杂	                  相对简单
总结：两种结构都能高效支持范围查询，选择依据主要是：
1、需要线程安全 → ConcurrentSkipListMap
2、单线程追求更高性能 → TreeMap
3、需要更严格的有序遍历 → TreeMap（红黑树的有序遍历更稳定）

13、Jetty、Netty、Tomcat
  1）选 Tomcat 如果：
  开发标准 Java Web 应用（Spring MVC/JSP）。
  需要开箱即用的 Servlet 功能（如 Filter、Session）。
  2）选 Jetty 如果：
  追求轻量级和快速启动（如微服务、嵌入式应用）。
  需要更好的 HTTP/2 或 WebSocket 支持。
  3）选 Netty 如果：
  需要超高并发（如长连接、即时通讯）。
  开发非 HTTP 协议（如自定义二进制 RPC 协议）。
  
  场景	              推荐技术栈
  传统企业级 Web 应用	Spring Boot + Tomcat
  云原生微服务	        Spring Boot + Jetty（或 Undertow）
  高性能 API 网关	    Netty + 自定义协议
  游戏服务器	          Netty + Protobuf

14、使用redis缓存如果10w个直播间商品需要更新怎么办
定时任务分片执行，如果有200台机器，那么给200台机器下发一个0~199的随机数，然后查询直播间id，用id对200取模，余数等于下发的随机数，就更新这个直播间的商品


15、缓存一致性解决方案
弱一致：延迟双删：先删除，在更新，在删除
强一致性
  1、使用分布式锁，
    1）先更新，在删除（存在问题：1、缓存删除失败-通过重试解决，2、缓存击穿的问题-加锁解决。在缓存操作使用相同的key，例如同一个直播间）
    2）先更新，在更新（存在问题：1、读写都会更新缓存，导致缓存不一致，2、缓存更新失败的问题，导致数据不一致）
    3）先更新，在删除，异步更新缓存。比较好的方案。（增加定时任务，实现缓存与数据库的定期比对对不一致的数据进行自动修复）
  2、串行化：读写两个请求，放入一个有序队列，先进先出，有序消费-rocketmq顺序消息。

16、redis大key怎么解决
背景：缓存直播间id的所有商品最多500个。且有序的，需要分页查询。还需要更新缓存
解答：二级索引来解决，使用zset分页排序，用排序字段做分数，用商品id做member。使用hash来存储分片后的商品数据。并且可以根据商品id更新缓存。
流程：创建直播预告-商品预热（写入）；提前把商品写入缓存中，zset和hash中。hash中的商品是需要分片的，比如10个分片，商品id对10取模，然后分摊到每个分片中。
查询缓存（读请求）：local goodsIds = redis.call('ZRANGE', KEYS[1], start, stop)。start, stop是分页的开始和结束需要提前算好，然后返回goodsIds是分页有序的数据
然后在批量查询hash中分片的数据，返回商品的全部信息，比如是20个，但是批量查询破坏了顺序性，所以在内存根据排序字段在做一次排序。
问题：分片导致key不同，映射不同solt槽，无法执行批量查询，优化：1、可以改成并行查询，2、使用Hash Tag映射同一个槽

17、跳跃表，红黑树，二叉树，b+tree区别

18、mysql执行顺序
  FROM 和 JOIN：确定数据来源表
  WHERE：过滤行数据
  GROUP BY：分组数据
  HAVING：过滤分组后的数据
  SELECT：选择要返回的列
  DISTINCT：去除重复行
  ORDER BY：排序结果
  LIMIT/OFFSET：限制返回行数

19、线程的状态流转
操作系统通用状态	  Java线程状态	                    说明
新建	            NEW	                            线程对象已创建但未启动
就绪	            RUNNABLE	                      线程可运行，等待CPU调度
运行	            RUNNABLE	                      Java将"就绪"和"运行"都归为RUNNABLE
阻塞	            BLOCKED/WAITING/TIMED_WAITING	  Java细分为三种阻塞状态
终止	            TERMINATED	                     线程执行完毕

20、dubbo和http区别，http1和http2的区别，websocket和http区别

21、kafka消费者超时导致重分配，批量拉取时怎么消费
即使批量拉取，消费者也是顺序消费，因为要正确提交offset，当消费者超时没有提交offset会触发reblance。
mafka开启并行消费，一个线程负责批量拉取，然后消费者框架内部维护了一个线程池，并行多线程调用消费者的方法，
这种情况下offset怎么保证，那就需要框架内主线程做汇总，统一提交最小的offset，不会让子线程来提交，防止消息丢失

22、用栈实现一个队列（算法题）
两个栈，一个方法放入第一个栈，一个方法负责从第一个取出来放入第二个，并且从第二个取出

23、redis原生命令mget和Pipeline区别，Pipeline和redis事务区别，redis原型命令setnx参数和作用
1、mget作用
    单命令批量操作：MGET 是一个原子性命令，可以一次性获取多个 key 的值
    服务器端实现：Redis 服务器原生支持 MGET 命令
    使用简单：只需发送一个命令即可获取多个值
    限制：只能用于 GET 操作，不能混合其他命令
    （跨slot报错同Pipeline）
2、多个命令的批量操作，	不保证原子性
     1) redis事务原子性：执行原子性：所有命令在EXEC时作为一个单元连续执行，执行期间不会被其他客户端命令打断
        MULTI
        SET foo "hello"
        INCR foo  # 类型错误
        SET bar "world"
        EXEC  # 返回 [OK, (error), OK]
      2) mysql事务原子性；要么全部成功，要么全部失败
3、redis事务部分原子性（不能回滚），保证隔离性
4、SET key value NX EX 30，分布式锁，加锁并设置过期时间，redis原生命令 ，保证原子性

24、协程和线程的区别
线程是操作系统内核调度的基本单位，一个线程对应一个系统os线程，当线程创建销毁切换时都需要cpu在用户态和内核态切换来完成，所以线程是比较宝贵的资源
协程又叫虚拟线程，是jvm来管理的只运行在用户态，一个线程可对应多个协程。当一个协程在读取sql时，此时这个线程可以来处理其他协程的逻辑。从而达到百万并发的目标

25、kakfa如何实现重试
1）基于消息投递机制，如果出现异常，不提交offset，再次拉取时就会重复消费
2）消费者重试，使用while循环，catch异常，+1直到达到最大次数，时间依赖sleep
3）mafka机制：将消费失败的消息投递到，指定的重试topic_delay中，这样不会阻塞后续消息的消费。重试几次后，放入私信队列队中。每一个重试队列和延迟队列都是独立的基于原topic拼接的

26、es为什么是准实时的？
因为默认情况下，ES每1秒自动刷新一次索引，新写入的数据只有在刷新后才会被搜索到，这种刷新操作会创建一个新的可搜索段
文档写入 → 内存缓冲区 → 事务日志（translog）→ 刷新到段 → 可搜索
ES需要定期合并小的段文件以提高搜索效率：合并过程会影响数据的实时可见性
  什么时段文件：
  可以理解为倒排索引的文件，每次refresh(默认1秒)都会产生一个新段，如果不合并，短期内会产生大量小段文件，搜索时需要检查所有段，性能急剧下降

27、hashmap的头插法和尾插法的区别
头插法：每次插入数据都是放在头节点，新插入的节点指针指向原头节点，例如我要插入abc，那么插入之后链表：cba。放我扩容时遍历c-b-a，先将c插入新map，然后b然后a，有反转了一遍新链表变成abc了
尾插法：每次插入数据都是放在尾节点。效率不如头插法，因为需要遍历链表。但是可以避免死循环，尾插法始终保持abc

28、mysql的insert释放会产生死锁
会：事务1插入id=20的数据行，事务未提交，事务2和3等待事务1结束，事务1提交/回滚，此时mysql同时唤醒事务2-3，注意是同时唤醒。
此时事务2-3就会对id=20数据行同时加锁。这个时候就会产生死锁，但是mysql会回滚一个事务。
注意：mysql是同时唤醒。java中的锁只是在新加入的线程会枪锁，如果线程1持有锁，线程2和3等待，这个时候2和3是在monter的等待队列中，唤醒也是先2后3.但如果如果刚进来线程4，那么他会先抢锁
