1、外卖境内和境外有啥差异，和相同点


2、职业规划，如何做好一个管理者
  1）、技术和业务提升：技术和业务上需要提升技术的广度和深度，并且从更层角度看待问题和架构，业务上对业务理解程度要更透彻，并且能把控业务的发展走向，并转成对应的技术目标
  2）、管理上的提升：人员的管理和需求的管理：
    1、人的管理：向上汇报：结论先行原则，例如：进度多少，风险是什么，然后再讲原因。向下指导：人员上做好定期沟通，根据个人意向为期制定合理目标，以便让成员打成目标有更好的成就感，
    2、需求管理：需求池维护整理，优先级排序，合理分配高优先级需求

2.1、在现在的公司中你有哪些成长？
1）技术上：
  1、技术深度：使用新的框架有看底层的源码，对原理有一定的了解，
  2、实战能力：主导解决了线上mysql死锁，消息积压，redis集群抖动等题，并沉淀出相应的文档
  3、架构能力：对高并大高流量系统架构设计和技术选型的能力也有一定的提升
2）管理上：1、负责日常小团队的管理。包括：日常指导、目标指定和考核、需求分配

2.2、对实习生应届生如何管理？
1）需求分配：
2）日常工作指导：业务指导、技术指导、线上问题解决指导
3）制定目标并考核：熟悉期、上手期、提升期




3、外卖管控服务的设计考虑哪些？怎么搭建的？
外卖骑手端，骑手管控服务业务流程餐

4、你做着的这些难点在哪？是怎么解决的？
业务的复杂性带来代码的复杂性，如果无脑的流水开发，对日后的增量迭代带来是难维护，扩展性差，上线风险大。
所以在项目初期，需要理解业务，根据业务搭建服务，管控服务就是对骑手的履约过程的管控与治理。按照配送过程分析，骑手配送过程中肯定会有违规，不履约，或者遇到一些问题。
所以针对不履约过程就要对骑手处罚，那怎么处罚，那根据什么处罚呢，那就看骑手有哪些违规，不同违规匹配不同处罚方案，那违规怎么生成，就是需要对骑手履约过程判责，判责就需要根据具体场景具体分析，是送达超时，还是延误到店等。


5、讲讲项目
一、判责域
  1）判责类型：
    完成单判责：送达超时判责、送达位置异常判责、提前点送达判责、延误到店判责、到点位置异常判责、延误取餐判责、取餐位置异常判责
    取消单：取消单盼责，非取消单判责。
    封控单判责：风控异常单判责，风控虚假单判责
  2）判责结果：基于判责逻辑最终产出的结果，判责结果中明确责任方、违规类型，以及是否被免责等信息
  3）判责幂等：租户code_判责场景code_任务单id
经过判责之后，会生成违规类型。先有判责结果再有违规结果，如果盼着结果被免责，就不生成违规，如果盼着结果被申诉成功，违规会被作废

违规类型：经判责后产出的判责结果类型、例如送餐位置异常，异常单、开工抽检不通过等
违规结果：用于处罚、申诉的核心数据依据、一定先有判责结果，再有违规结果、如果判责结果被自动免责，则不再生成违规结果，如果违规结果被申诉通过，则违规结果会被作废，不再针对该违规进行处罚。

二、处罚域
  1、处罚模式：单次处罚、违规聚次处罚、任务单聚次处罚
  2、处罚方案：针对处罚模式和违规类型进行处罚的执行策略的具体描述
  3、处罚结果：根据违规类型匹配对应的处罚方案，进一步根据违规次数匹配到对应的处罚规则，产生对应的处罚结果，比如处罚非本人跑单3次，限制开工3天



6、diffset原理和diff注解的原理，diffset是否承接正常流量？
1）diffset原理：aop方式，拦截需要diff的方法，在切面中，通过配置内容，找到目标的类和方法，以及appkey，模拟客户端通过okhttp，异步线程池发送一个http请求。然后执行原方法（diffset方法），
原方法结束之后，再创建一个异步线程，在线程中通过CompletableFuture获取默认set中结果，进行对比，对比之后把结果放入es
2）diff注解：请求过来，通过切面方式实现，在切面中，执行原方法，把目标方法封装到Supplier中，然后开启异步线程，把目标方法的查询结果 和 封装的Supplier传入异步线程，异步线程执行：Object target = targetSupplier.get();// 在异步线程中执行目标方法
然后将传入的结果和异步的结果，做比较


7、如何实现支付系统，如何实现一个抢红包系统，设计一个lru算法

8、线程阻塞会导致cpu飙升么？锁的等待和join阻塞有什么区别
  当一个线程进入阻塞状态（如 WAITING、TIMED_WAITING、BLOCKED）时：
  线程被挂起，不再被操作系统调度执行。
  CPU不会分配时间片给阻塞的线程，因此不会占用CPU计算资源。
  线程进入等待队列，直到某个条件（如I/O完成、锁释放、notify() 调用等）触发唤醒。

9、微服务的背景下，多机房部署，如何降低延迟，有哪些负载均衡策略？
主流方案：通常集成加权轮询（结合实时指标（CPU、延迟、错误率）加权之后，进行轮训）、最少连接和地域感知


10、线程阻塞是否会消耗cpu？，
线程阻塞本身不会消耗CPU，因为阻塞的线程不会被调度执行。
CPU飙升通常是由于阻塞后的唤醒、锁竞争（自旋🔒）或线程调度问题，而不是阻塞本身。
合理使用锁、线程池和异步I/O（如NIO）可以减少不必要的阻塞，提高系统性能。


11、redis使用zset做排行榜，插入和查找的时间复杂度是多少？
当排行榜的元素小雨128使用，使用压缩表，压缩表，查询和插入都是On，如果大于123使用跳跃表+哈希表实现，redis底层维护两个数据结构，单通过key查询某一个人排行使用的是哈希表o1，当范围查询使用的是跳跃表。ologn

12、java中哪种数据结构类似跳跃表？有封装好的对象么？
ConcurrentSkipListMap 和 ConcurrentSkipListSet：跳跃表
TreeMap 和 TreeSet：红黑树

对比总结
特性	        ConcurrentSkipListMap	  TreeMap
底层结构	      跳跃表	                  红黑树
查询复杂度	    O(log n)	              O(log n)
插入复杂度	    O(log n)	              O(log n)
范围查询复杂度	O(log n + m)	          O(log n + m)
线程安全	      是	                    否
内存占用	      较高（多层指针）	          较低
实现难度	      较复杂	                  相对简单
总结：两种结构都能高效支持范围查询，选择依据主要是：
1、需要线程安全 → ConcurrentSkipListMap
2、单线程追求更高性能 → TreeMap
3、需要更严格的有序遍历 → TreeMap（红黑树的有序遍历更稳定）

13、Jetty、Netty、Tomcat
  1）选 Tomcat 如果：
  开发标准 Java Web 应用（Spring MVC/JSP）。
  需要开箱即用的 Servlet 功能（如 Filter、Session）。
  2）选 Jetty 如果：
  追求轻量级和快速启动（如微服务、嵌入式应用）。
  需要更好的 HTTP/2 或 WebSocket 支持。
  3）选 Netty 如果：
  需要超高并发（如长连接、即时通讯）。
  开发非 HTTP 协议（如自定义二进制 RPC 协议）。
  
  场景	              推荐技术栈
  传统企业级 Web 应用	Spring Boot + Tomcat
  云原生微服务	        Spring Boot + Jetty（或 Undertow）
  高性能 API 网关	    Netty + 自定义协议
  游戏服务器	          Netty + Protobuf

14、使用redis缓存如果10w个直播间商品需要更新怎么办
定时任务分片执行，如果有200台机器，那么给200台机器下发一个0~199的随机数，然后查询直播间id，用id对200取模，余数等于下发的随机数，就更新这个直播间的商品


15、缓存一致性解决方案
弱一致：延迟双删：先删除，在更新，在删除
强一致性
  1、使用分布式锁，
    1）先更新，在删除（存在问题：1、缓存删除失败-通过重试解决，2、缓存击穿的问题-加锁解决。在缓存操作使用相同的key，例如同一个直播间）
    2）先更新，在更新（存在问题：1、读写都会更新缓存，导致缓存不一致，2、缓存更新失败的问题，导致数据不一致）
    3）先更新，在删除，异步更新缓存。比较好的方案。（增加定时任务，实现缓存与数据库的定期比对对不一致的数据进行自动修复）
  2、串行化：读写两个请求，放入一个有序队列，先进先出，有序消费-rocketmq顺序消息。

16、redis大key怎么解决
背景：缓存直播间id的所有商品最多500个。且有序的，需要分页查询。还需要更新缓存
解答：二级索引来解决，使用zset分页排序，用排序字段做分数，用商品id做member。使用hash来存储分片后的商品数据。并且可以根据商品id更新缓存。
流程：创建直播预告-商品预热（写入）；提前把商品写入缓存中，zset和hash中。hash中的商品是需要分片的，比如10个分片，商品id对10取模，然后分摊到每个分片中。
查询缓存（读请求）：local goodsIds = redis.call('ZRANGE', KEYS[1], start, stop)。start, stop是分页的开始和结束需要提前算好，然后返回goodsIds是分页有序的数据
然后在批量查询hash中分片的数据，返回商品的全部信息，比如是20个，但是批量查询破坏了顺序性，所以在内存根据排序字段在做一次排序。
问题：分片导致key不同，映射不同solt槽，无法执行批量查询，优化：1、可以改成并行查询，2、使用Hash Tag映射同一个槽

17、跳跃表，红黑树，二叉树，b+tree区别

18、mysql执行顺序
  FROM 和 JOIN：确定数据来源表
  WHERE：过滤行数据
  GROUP BY：分组数据
  HAVING：过滤分组后的数据
  SELECT：选择要返回的列
  DISTINCT：去除重复行
  ORDER BY：排序结果
  LIMIT/OFFSET：限制返回行数

19、线程的状态流转
操作系统通用状态	  Java线程状态	                    说明
新建	            NEW	                            线程对象已创建但未启动
就绪	            RUNNABLE	                      线程可运行，等待CPU调度
运行	            RUNNABLE	                      Java将"就绪"和"运行"都归为RUNNABLE
阻塞	            BLOCKED/WAITING/TIMED_WAITING	  Java细分为三种阻塞状态
终止	            TERMINATED	                     线程执行完毕

20、dubbo和http区别，http1和http2的区别，websocket和http区别

21、kafka消费者超时导致重分配，批量拉取时怎么消费
即使批量拉取，消费者也是顺序消费，因为要正确提交offset，当消费者超时没有提交offset会触发reblance。
mafka开启并行消费，一个线程负责批量拉取，然后消费者框架内部维护了一个线程池，并行多线程调用消费者的方法，
这种情况下offset怎么保证，那就需要框架内主线程做汇总，统一提交最小的offset，不会让子线程来提交，防止消息丢失

22、用栈实现一个队列（算法题）
两个栈，一个方法放入第一个栈，一个方法负责从第一个取出来放入第二个，并且从第二个取出

23、redis原生命令mget和Pipeline区别，Pipeline和redis事务区别，redis原型命令setnx参数和作用
1、mget作用
    单命令批量操作：MGET 是一个原子性命令，可以一次性获取多个 key 的值
    服务器端实现：Redis 服务器原生支持 MGET 命令
    使用简单：只需发送一个命令即可获取多个值
    限制：只能用于 GET 操作，不能混合其他命令
    （跨slot报错同Pipeline）
2、多个命令的批量操作，	不保证原子性
     1) redis事务原子性：执行原子性：所有命令在EXEC时作为一个单元连续执行，执行期间不会被其他客户端命令打断
        MULTI
        SET foo "hello"
        INCR foo  # 类型错误
        SET bar "world"
        EXEC  # 返回 [OK, (error), OK]
      2) mysql事务原子性；要么全部成功，要么全部失败
3、redis事务部分原子性（不能回滚），保证隔离性
4、SET key value NX EX 30，分布式锁，加锁并设置过期时间，redis原生命令 ，保证原子性


24、协程和线程的区别
线程是操作系统内核调度的基本单位，一个线程对应一个系统os线程，当线程创建销毁切换时都需要cpu在用户态和内核态切换来完成，所以线程是比较宝贵的资源
协程又叫虚拟线程，是jvm来管理的只运行在用户态，一个线程可对应多个协程。当一个协程在读取sql时，此时这个线程可以来处理其他协程的逻辑。从而达到百万并发的目标


  
