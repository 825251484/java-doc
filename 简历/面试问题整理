1、外卖境内和境外有啥差异，和相同点


2、职业规划，如何做好一个管理者
  1）、技术和业务提升：技术和业务上需要提升技术的广度和深度，并且从更层角度看待问题和架构，业务上对业务理解程度要更透彻，并且能把控业务的发展走向，并转成对应的技术目标
  2）、管理上的提升：人员的管理和需求的管理：
    1、人的管理：向上汇报：结论先行原则，例如：进度多少，风险是什么，然后再讲原因。向下指导：人员上做好定期沟通，根据个人意向为期制定合理目标，以便让成员打成目标有更好的成就感，
    2、需求管理：需求池维护整理，优先级排序，合理分配高优先级需求


3、外卖管控服务的设计考虑哪些？怎么搭建的？
外卖骑手端，骑手管控服务业务流程餐

4、你做着的这些难点在哪？是怎么解决的？
业务的复杂性带来代码的复杂性，如果无脑的流水开发，对日后的增量迭代带来是难维护，扩展性差，上线风险大。
所以在项目初期，需要理解业务，根据业务搭建服务，管控服务就是对骑手的履约过程的管控与治理。按照配送过程分析，骑手配送过程中肯定会有违规，不履约，或者遇到一些问题。
所以针对不履约过程就要对骑手处罚，那怎么处罚，那根据什么处罚呢，那就看骑手有哪些违规，不同违规匹配不同处罚方案，那违规怎么生成，就是需要对骑手履约过程判责，判责就需要根据具体场景具体分析，是送达超时，还是延误到店等。


5、讲讲项目
判责类型：
完成单判责：送达超时判责、送达位置异常判责、提前点送达判责、延误到店判责、到点位置异常判责、延误取餐判责、取餐位置异常判责
取消单：取消单盼责，非取消单判责。
封控单判责：
判责之后会产生，判责结果：责任方，违规类型，是否免责等。

经过判责之后，会生成违规类型。先有判责结果再有违规结果，如果盼着结果被免责，就不生成违规，如果盼着结果被申诉成功，违规会被作废


6、diffset原理和diff注解的原理，diffset是否承接正常流量？
1）diffset原理：aop方式，拦截需要diff的方法，在切面中，通过配置内容，找到目标的类和方法，以及appkey，模拟客户端通过okhttp，异步线程池发送一个http请求。然后执行原方法（diffset方法），
原方法结束之后，再创建一个异步线程，在线程中通过CompletableFuture获取默认set中结果，进行对比，对比之后把结果放入es
2）diff注解：请求过来，通过切面方式实现，在切面中，执行原方法，把目标方法封装到Supplier中，然后开启异步线程，把目标方法的查询结果 和 封装的Supplier传入异步线程，异步线程执行：Object target = targetSupplier.get();// 在异步线程中执行目标方法
然后将传入的结果和异步的结果，做比较


7、如何实现支付系统，如何实现一个抢红包系统，设计一个lru算法

8、线程阻塞会导致cpu飙升么？锁的等待和join阻塞有什么区别
  当一个线程进入阻塞状态（如 WAITING、TIMED_WAITING、BLOCKED）时：
  线程被挂起，不再被操作系统调度执行。
  CPU不会分配时间片给阻塞的线程，因此不会占用CPU计算资源。
  线程进入等待队列，直到某个条件（如I/O完成、锁释放、notify() 调用等）触发唤醒。

9、微服务的背景下，多机房部署，如何降低延迟，有哪些负载均衡策略？
主流方案：通常集成加权轮询（结合实时指标（CPU、延迟、错误率）加权之后，进行轮训）、最少连接和地域感知


10、线程阻塞是否会消耗cpu？，
线程阻塞本身不会消耗CPU，因为阻塞的线程不会被调度执行。
CPU飙升通常是由于阻塞后的唤醒、锁竞争（自旋🔒）或线程调度问题，而不是阻塞本身。
合理使用锁、线程池和异步I/O（如NIO）可以减少不必要的阻塞，提高系统性能。


11、redis使用zset做排行榜，插入和查找的时间复杂度是多少？
当排行榜的元素小雨128使用，使用压缩表，压缩表，查询和插入都是On，如果大于123使用跳跃表+哈希表实现，redis底层维护两个数据结构，单通过key查询某一个人排行使用的是哈希表o1，当范围查询使用的是跳跃表。ologn

12、java中哪种数据结构类似跳跃表？有封装好的对象么？
ConcurrentSkipListMap 和 ConcurrentSkipListSet：跳跃表
TreeMap 和 TreeSet：红黑树

对比总结
特性	        ConcurrentSkipListMap	  TreeMap
底层结构	      跳跃表	                  红黑树
查询复杂度	    O(log n)	              O(log n)
插入复杂度	    O(log n)	              O(log n)
范围查询复杂度	O(log n + m)	          O(log n + m)
线程安全	      是	                    否
内存占用	      较高（多层指针）	          较低
实现难度	      较复杂	                  相对简单
总结：两种结构都能高效支持范围查询，选择依据主要是：
1、需要线程安全 → ConcurrentSkipListMap
2、单线程追求更高性能 → TreeMap
3、需要更严格的有序遍历 → TreeMap（红黑树的有序遍历更稳定）

13、Jetty、Netty、Tomcat
  1）选 Tomcat 如果：
  开发标准 Java Web 应用（Spring MVC/JSP）。
  需要开箱即用的 Servlet 功能（如 Filter、Session）。
  2）选 Jetty 如果：
  追求轻量级和快速启动（如微服务、嵌入式应用）。
  需要更好的 HTTP/2 或 WebSocket 支持。
  3）选 Netty 如果：
  需要超高并发（如长连接、即时通讯）。
  开发非 HTTP 协议（如自定义二进制 RPC 协议）。
  
  场景	              推荐技术栈
  传统企业级 Web 应用	Spring Boot + Tomcat
  云原生微服务	        Spring Boot + Jetty（或 Undertow）
  高性能 API 网关	    Netty + 自定义协议
  游戏服务器	          Netty + Protobuf

14、使用redis缓存如果10w个直播间商品需要更新怎么办
定时任务分片执行，如果有200台机器，那么给200台机器下发一个0~199的随机数，然后查询直播间id，用id对200取模，余数等于下发的随机数，就更新这个直播间的商品


15、缓存一致性解决方案
弱一致：延迟双删：先删除，在更新，在删除
强一致性
  1、使用分布式锁，
    1）先更新，在删除（存在问题：1、缓存删除失败-通过重试解决，2、缓存击穿的问题-加锁解决。在缓存操作使用相同的key，例如同一个直播间）
    2）先更新，在更新（存在问题：1、读写都会更新缓存，导致缓存不一致，2、缓存更新失败的问题，导致数据不一致）
    3）先更新，在删除，异步更新缓存。比较好的方案。（增加定时任务，实现缓存与数据库的定期比对对不一致的数据进行自动修复）
  2、串行化：读写两个请求，放入一个有序队列，先进先出，有序消费-rocketmq顺序消息。

16、redis大key怎么解决
背景：缓存直播间id的所有商品最多500个。且有序的，需要分页查询。还需要更新缓存
解答：二级索引来解决，使用zset分页排序，用排序字段做分数，用商品id做member。使用hash来存储分片后的商品数据。并且可以根据商品id更新缓存。
流程：创建直播预告-商品预热（写入）；提前把商品写入缓存中，zset和hash中。hash中的商品是需要分片的，比如10个分片，商品id对10取模，然后分摊到每个分片中。
查询缓存（读请求）：local goodsIds = redis.call('ZRANGE', KEYS[1], start, stop)。start, stop是分页的开始和结束需要提前算好，然后返回goodsIds是分页有序的数据
然后在批量查询hash中分片的数据，返回商品的全部信息，比如是20个，但是批量查询破坏了顺序性，所以在内存根据排序字段在做一次排序。
问题：分片导致key不同，映射不同solt槽，无法执行批量查询，优化：1、可以改成并行查询，2、使用Hash Tag映射同一个槽

17、跳跃表，红黑树，二叉树，b+tree区别
